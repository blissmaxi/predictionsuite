/* tslint:disable */
/* eslint-disable */
/**
 * Kalshi Trade API Manual Endpoints
 * Manually defined OpenAPI spec for endpoints being migrated to spec-first approach
 *
 * The version of the OpenAPI document: 3.4.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, BaseAPI } from '../base';
/**
 * OrdersApi - axios parameter creator
 */
export const OrdersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Endpoint for amending the max number of fillable contracts and/or price in an existing order. Max fillable contracts is `remaining_count` + `fill_count`.
         * @summary Amend Order
         * @param {string} orderId Order ID
         * @param {AmendOrderRequest} amendOrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amendOrder: (orderId_1, amendOrderRequest_1, ...args_1) => __awaiter(this, [orderId_1, amendOrderRequest_1, ...args_1], void 0, function* (orderId, amendOrderRequest, options = {}) {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('amendOrder', 'orderId', orderId);
            // verify required parameter 'amendOrderRequest' is not null or undefined
            assertParamExists('amendOrder', 'amendOrderRequest', amendOrderRequest);
            const localVarPath = `/portfolio/orders/{order_id}/amend`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(amendOrderRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for cancelling up to 20 orders at once.
         * @summary Batch Cancel Orders
         * @param {BatchCancelOrdersRequest} batchCancelOrdersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchCancelOrders: (batchCancelOrdersRequest_1, ...args_1) => __awaiter(this, [batchCancelOrdersRequest_1, ...args_1], void 0, function* (batchCancelOrdersRequest, options = {}) {
            // verify required parameter 'batchCancelOrdersRequest' is not null or undefined
            assertParamExists('batchCancelOrders', 'batchCancelOrdersRequest', batchCancelOrdersRequest);
            const localVarPath = `/portfolio/orders/batched`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(batchCancelOrdersRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for submitting a batch of orders. Each order in the batch is counted against the total rate limit for order operations. Consequently, the size of the batch is capped by the current per-second rate-limit configuration applicable to the user. At the moment of writing, the limit is 20 orders per batch.
         * @summary Batch Create Orders
         * @param {BatchCreateOrdersRequest} batchCreateOrdersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchCreateOrders: (batchCreateOrdersRequest_1, ...args_1) => __awaiter(this, [batchCreateOrdersRequest_1, ...args_1], void 0, function* (batchCreateOrdersRequest, options = {}) {
            // verify required parameter 'batchCreateOrdersRequest' is not null or undefined
            assertParamExists('batchCreateOrders', 'batchCreateOrdersRequest', batchCreateOrdersRequest);
            const localVarPath = `/portfolio/orders/batched`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(batchCreateOrdersRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for canceling orders. The value for the orderId should match the id field of the order you want to decrease. Commonly, DELETE-type endpoints return 204 status with no body content on success. But we can\'t completely delete the order, as it may be partially filled already. Instead, the DeleteOrder endpoint reduce the order completely, essentially zeroing the remaining resting contracts on it. The zeroed order is returned on the response payload as a form of validation for the client.
         * @summary Cancel Order
         * @param {string} orderId Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder: (orderId_1, ...args_1) => __awaiter(this, [orderId_1, ...args_1], void 0, function* (orderId, options = {}) {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('cancelOrder', 'orderId', orderId);
            const localVarPath = `/portfolio/orders/{order_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for submitting orders in a market. Each user is limited to 200 000 open orders at a time.
         * @summary Create Order
         * @param {CreateOrderRequest} createOrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder: (createOrderRequest_1, ...args_1) => __awaiter(this, [createOrderRequest_1, ...args_1], void 0, function* (createOrderRequest, options = {}) {
            // verify required parameter 'createOrderRequest' is not null or undefined
            assertParamExists('createOrder', 'createOrderRequest', createOrderRequest);
            const localVarPath = `/portfolio/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(createOrderRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for decreasing the number of contracts in an existing order. This is the only kind of edit available on order quantity. Cancelling an order is equivalent to decreasing an order amount to zero.
         * @summary Decrease Order
         * @param {string} orderId Order ID
         * @param {DecreaseOrderRequest} decreaseOrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decreaseOrder: (orderId_1, decreaseOrderRequest_1, ...args_1) => __awaiter(this, [orderId_1, decreaseOrderRequest_1, ...args_1], void 0, function* (orderId, decreaseOrderRequest, options = {}) {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('decreaseOrder', 'orderId', orderId);
            // verify required parameter 'decreaseOrderRequest' is not null or undefined
            assertParamExists('decreaseOrder', 'decreaseOrderRequest', decreaseOrderRequest);
            const localVarPath = `/portfolio/orders/{order_id}/decrease`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(decreaseOrderRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for getting a single order.
         * @summary Get Order
         * @param {string} orderId Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder: (orderId_1, ...args_1) => __awaiter(this, [orderId_1, ...args_1], void 0, function* (orderId, options = {}) {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrder', 'orderId', orderId);
            const localVarPath = `/portfolio/orders/{order_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for getting an order\'s queue position in the order book. This represents the amount of orders that need to be matched before this order receives a partial or full match. Queue position is determined using a price-time priority.
         * @summary Get Order Queue Position
         * @param {string} orderId Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderQueuePosition: (orderId_1, ...args_1) => __awaiter(this, [orderId_1, ...args_1], void 0, function* (orderId, options = {}) {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrderQueuePosition', 'orderId', orderId);
            const localVarPath = `/portfolio/orders/{order_id}/queue_position`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for getting queue positions for all resting orders. Queue position represents the number of contracts that need to be matched before an order receives a partial or full match, determined using price-time priority.
         * @summary Get Queue Positions for Orders
         * @param {string} [marketTickers] Comma-separated list of market tickers to filter by
         * @param {string} [eventTicker] Event ticker to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderQueuePositions: (marketTickers_1, eventTicker_1, ...args_1) => __awaiter(this, [marketTickers_1, eventTicker_1, ...args_1], void 0, function* (marketTickers, eventTicker, options = {}) {
            const localVarPath = `/portfolio/orders/queue_positions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            if (marketTickers !== undefined) {
                localVarQueryParameter['market_tickers'] = marketTickers;
            }
            if (eventTicker !== undefined) {
                localVarQueryParameter['event_ticker'] = eventTicker;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Restricts the response to orders that have a certain status: resting, canceled, or executed.
         * @summary Get Orders
         * @param {string} [ticker] Filter by market ticker
         * @param {string} [eventTicker] Event ticker of desired positions. Multiple event tickers can be provided as a comma-separated list (maximum 10).
         * @param {number} [minTs] Filter items after this Unix timestamp
         * @param {number} [maxTs] Filter items before this Unix timestamp
         * @param {string} [status] Filter by status. Possible values depend on the endpoint.
         * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 200.
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders: (ticker_1, eventTicker_1, minTs_1, maxTs_1, status_1, limit_1, cursor_1, ...args_1) => __awaiter(this, [ticker_1, eventTicker_1, minTs_1, maxTs_1, status_1, limit_1, cursor_1, ...args_1], void 0, function* (ticker, eventTicker, minTs, maxTs, status, limit, cursor, options = {}) {
            const localVarPath = `/portfolio/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }
            if (eventTicker !== undefined) {
                localVarQueryParameter['event_ticker'] = eventTicker;
            }
            if (minTs !== undefined) {
                localVarQueryParameter['min_ts'] = minTs;
            }
            if (maxTs !== undefined) {
                localVarQueryParameter['max_ts'] = maxTs;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * OrdersApi - functional programming interface
 */
export const OrdersApiFp = function (configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration);
    return {
        /**
         *  Endpoint for amending the max number of fillable contracts and/or price in an existing order. Max fillable contracts is `remaining_count` + `fill_count`.
         * @summary Amend Order
         * @param {string} orderId Order ID
         * @param {AmendOrderRequest} amendOrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amendOrder(orderId, amendOrderRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.amendOrder(orderId, amendOrderRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for cancelling up to 20 orders at once.
         * @summary Batch Cancel Orders
         * @param {BatchCancelOrdersRequest} batchCancelOrdersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchCancelOrders(batchCancelOrdersRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.batchCancelOrders(batchCancelOrdersRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for submitting a batch of orders. Each order in the batch is counted against the total rate limit for order operations. Consequently, the size of the batch is capped by the current per-second rate-limit configuration applicable to the user. At the moment of writing, the limit is 20 orders per batch.
         * @summary Batch Create Orders
         * @param {BatchCreateOrdersRequest} batchCreateOrdersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchCreateOrders(batchCreateOrdersRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.batchCreateOrders(batchCreateOrdersRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for canceling orders. The value for the orderId should match the id field of the order you want to decrease. Commonly, DELETE-type endpoints return 204 status with no body content on success. But we can\'t completely delete the order, as it may be partially filled already. Instead, the DeleteOrder endpoint reduce the order completely, essentially zeroing the remaining resting contracts on it. The zeroed order is returned on the response payload as a form of validation for the client.
         * @summary Cancel Order
         * @param {string} orderId Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(orderId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelOrder(orderId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for submitting orders in a market. Each user is limited to 200 000 open orders at a time.
         * @summary Create Order
         * @param {CreateOrderRequest} createOrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(createOrderRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createOrder(createOrderRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for decreasing the number of contracts in an existing order. This is the only kind of edit available on order quantity. Cancelling an order is equivalent to decreasing an order amount to zero.
         * @summary Decrease Order
         * @param {string} orderId Order ID
         * @param {DecreaseOrderRequest} decreaseOrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decreaseOrder(orderId, decreaseOrderRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.decreaseOrder(orderId, decreaseOrderRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for getting a single order.
         * @summary Get Order
         * @param {string} orderId Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(orderId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrder(orderId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for getting an order\'s queue position in the order book. This represents the amount of orders that need to be matched before this order receives a partial or full match. Queue position is determined using a price-time priority.
         * @summary Get Order Queue Position
         * @param {string} orderId Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderQueuePosition(orderId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrderQueuePosition(orderId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for getting queue positions for all resting orders. Queue position represents the number of contracts that need to be matched before an order receives a partial or full match, determined using price-time priority.
         * @summary Get Queue Positions for Orders
         * @param {string} [marketTickers] Comma-separated list of market tickers to filter by
         * @param {string} [eventTicker] Event ticker to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderQueuePositions(marketTickers, eventTicker, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrderQueuePositions(marketTickers, eventTicker, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Restricts the response to orders that have a certain status: resting, canceled, or executed.
         * @summary Get Orders
         * @param {string} [ticker] Filter by market ticker
         * @param {string} [eventTicker] Event ticker of desired positions. Multiple event tickers can be provided as a comma-separated list (maximum 10).
         * @param {number} [minTs] Filter items after this Unix timestamp
         * @param {number} [maxTs] Filter items before this Unix timestamp
         * @param {string} [status] Filter by status. Possible values depend on the endpoint.
         * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 200.
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(ticker, eventTicker, minTs, maxTs, status, limit, cursor, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrders(ticker, eventTicker, minTs, maxTs, status, limit, cursor, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * OrdersApi - factory interface
 */
export const OrdersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = OrdersApiFp(configuration);
    return {
        /**
         *  Endpoint for amending the max number of fillable contracts and/or price in an existing order. Max fillable contracts is `remaining_count` + `fill_count`.
         * @summary Amend Order
         * @param {string} orderId Order ID
         * @param {AmendOrderRequest} amendOrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amendOrder(orderId, amendOrderRequest, options) {
            return localVarFp.amendOrder(orderId, amendOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for cancelling up to 20 orders at once.
         * @summary Batch Cancel Orders
         * @param {BatchCancelOrdersRequest} batchCancelOrdersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchCancelOrders(batchCancelOrdersRequest, options) {
            return localVarFp.batchCancelOrders(batchCancelOrdersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for submitting a batch of orders. Each order in the batch is counted against the total rate limit for order operations. Consequently, the size of the batch is capped by the current per-second rate-limit configuration applicable to the user. At the moment of writing, the limit is 20 orders per batch.
         * @summary Batch Create Orders
         * @param {BatchCreateOrdersRequest} batchCreateOrdersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchCreateOrders(batchCreateOrdersRequest, options) {
            return localVarFp.batchCreateOrders(batchCreateOrdersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for canceling orders. The value for the orderId should match the id field of the order you want to decrease. Commonly, DELETE-type endpoints return 204 status with no body content on success. But we can\'t completely delete the order, as it may be partially filled already. Instead, the DeleteOrder endpoint reduce the order completely, essentially zeroing the remaining resting contracts on it. The zeroed order is returned on the response payload as a form of validation for the client.
         * @summary Cancel Order
         * @param {string} orderId Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(orderId, options) {
            return localVarFp.cancelOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for submitting orders in a market. Each user is limited to 200 000 open orders at a time.
         * @summary Create Order
         * @param {CreateOrderRequest} createOrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(createOrderRequest, options) {
            return localVarFp.createOrder(createOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for decreasing the number of contracts in an existing order. This is the only kind of edit available on order quantity. Cancelling an order is equivalent to decreasing an order amount to zero.
         * @summary Decrease Order
         * @param {string} orderId Order ID
         * @param {DecreaseOrderRequest} decreaseOrderRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decreaseOrder(orderId, decreaseOrderRequest, options) {
            return localVarFp.decreaseOrder(orderId, decreaseOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for getting a single order.
         * @summary Get Order
         * @param {string} orderId Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrder(orderId, options) {
            return localVarFp.getOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for getting an order\'s queue position in the order book. This represents the amount of orders that need to be matched before this order receives a partial or full match. Queue position is determined using a price-time priority.
         * @summary Get Order Queue Position
         * @param {string} orderId Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderQueuePosition(orderId, options) {
            return localVarFp.getOrderQueuePosition(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for getting queue positions for all resting orders. Queue position represents the number of contracts that need to be matched before an order receives a partial or full match, determined using price-time priority.
         * @summary Get Queue Positions for Orders
         * @param {string} [marketTickers] Comma-separated list of market tickers to filter by
         * @param {string} [eventTicker] Event ticker to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderQueuePositions(marketTickers, eventTicker, options) {
            return localVarFp.getOrderQueuePositions(marketTickers, eventTicker, options).then((request) => request(axios, basePath));
        },
        /**
         * Restricts the response to orders that have a certain status: resting, canceled, or executed.
         * @summary Get Orders
         * @param {string} [ticker] Filter by market ticker
         * @param {string} [eventTicker] Event ticker of desired positions. Multiple event tickers can be provided as a comma-separated list (maximum 10).
         * @param {number} [minTs] Filter items after this Unix timestamp
         * @param {number} [maxTs] Filter items before this Unix timestamp
         * @param {string} [status] Filter by status. Possible values depend on the endpoint.
         * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 200.
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(ticker, eventTicker, minTs, maxTs, status, limit, cursor, options) {
            return localVarFp.getOrders(ticker, eventTicker, minTs, maxTs, status, limit, cursor, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * OrdersApi - object-oriented interface
 */
export class OrdersApi extends BaseAPI {
    /**
     *  Endpoint for amending the max number of fillable contracts and/or price in an existing order. Max fillable contracts is `remaining_count` + `fill_count`.
     * @summary Amend Order
     * @param {string} orderId Order ID
     * @param {AmendOrderRequest} amendOrderRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    amendOrder(orderId, amendOrderRequest, options) {
        return OrdersApiFp(this.configuration).amendOrder(orderId, amendOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for cancelling up to 20 orders at once.
     * @summary Batch Cancel Orders
     * @param {BatchCancelOrdersRequest} batchCancelOrdersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    batchCancelOrders(batchCancelOrdersRequest, options) {
        return OrdersApiFp(this.configuration).batchCancelOrders(batchCancelOrdersRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for submitting a batch of orders. Each order in the batch is counted against the total rate limit for order operations. Consequently, the size of the batch is capped by the current per-second rate-limit configuration applicable to the user. At the moment of writing, the limit is 20 orders per batch.
     * @summary Batch Create Orders
     * @param {BatchCreateOrdersRequest} batchCreateOrdersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    batchCreateOrders(batchCreateOrdersRequest, options) {
        return OrdersApiFp(this.configuration).batchCreateOrders(batchCreateOrdersRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for canceling orders. The value for the orderId should match the id field of the order you want to decrease. Commonly, DELETE-type endpoints return 204 status with no body content on success. But we can\'t completely delete the order, as it may be partially filled already. Instead, the DeleteOrder endpoint reduce the order completely, essentially zeroing the remaining resting contracts on it. The zeroed order is returned on the response payload as a form of validation for the client.
     * @summary Cancel Order
     * @param {string} orderId Order ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelOrder(orderId, options) {
        return OrdersApiFp(this.configuration).cancelOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for submitting orders in a market. Each user is limited to 200 000 open orders at a time.
     * @summary Create Order
     * @param {CreateOrderRequest} createOrderRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createOrder(createOrderRequest, options) {
        return OrdersApiFp(this.configuration).createOrder(createOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for decreasing the number of contracts in an existing order. This is the only kind of edit available on order quantity. Cancelling an order is equivalent to decreasing an order amount to zero.
     * @summary Decrease Order
     * @param {string} orderId Order ID
     * @param {DecreaseOrderRequest} decreaseOrderRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decreaseOrder(orderId, decreaseOrderRequest, options) {
        return OrdersApiFp(this.configuration).decreaseOrder(orderId, decreaseOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for getting a single order.
     * @summary Get Order
     * @param {string} orderId Order ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrder(orderId, options) {
        return OrdersApiFp(this.configuration).getOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for getting an order\'s queue position in the order book. This represents the amount of orders that need to be matched before this order receives a partial or full match. Queue position is determined using a price-time priority.
     * @summary Get Order Queue Position
     * @param {string} orderId Order ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrderQueuePosition(orderId, options) {
        return OrdersApiFp(this.configuration).getOrderQueuePosition(orderId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for getting queue positions for all resting orders. Queue position represents the number of contracts that need to be matched before an order receives a partial or full match, determined using price-time priority.
     * @summary Get Queue Positions for Orders
     * @param {string} [marketTickers] Comma-separated list of market tickers to filter by
     * @param {string} [eventTicker] Event ticker to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrderQueuePositions(marketTickers, eventTicker, options) {
        return OrdersApiFp(this.configuration).getOrderQueuePositions(marketTickers, eventTicker, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Restricts the response to orders that have a certain status: resting, canceled, or executed.
     * @summary Get Orders
     * @param {string} [ticker] Filter by market ticker
     * @param {string} [eventTicker] Event ticker of desired positions. Multiple event tickers can be provided as a comma-separated list (maximum 10).
     * @param {number} [minTs] Filter items after this Unix timestamp
     * @param {number} [maxTs] Filter items before this Unix timestamp
     * @param {string} [status] Filter by status. Possible values depend on the endpoint.
     * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 200.
     * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOrders(ticker, eventTicker, minTs, maxTs, status, limit, cursor, options) {
        return OrdersApiFp(this.configuration).getOrders(ticker, eventTicker, minTs, maxTs, status, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }
}
