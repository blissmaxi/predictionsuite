"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Kalshi Trade API Manual Endpoints
 * Manually defined OpenAPI spec for endpoints being migrated to spec-first approach
 *
 * The version of the OpenAPI document: 3.4.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetMarketsMveFilterEnum = exports.GetMarketsStatusEnum = exports.GetMarketCandlesticksPeriodIntervalEnum = exports.MarketApi = exports.MarketApiFactory = exports.MarketApiFp = exports.MarketApiAxiosParamCreator = void 0;
const axios_1 = require("axios");
// URLSearchParams not necessarily used
// @ts-ignore
const url_1 = require("url");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * MarketApi - axios parameter creator
 */
const MarketApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Endpoint for retrieving candlestick data for multiple markets.  - Accepts up to 100 market tickers per request - Returns up to 10,000 candlesticks total across all markets - Returns candlesticks grouped by market_id - Optionally includes a synthetic initial candlestick for price continuity (see `include_latest_before_start` parameter)
         * @summary Batch Get Market Candlesticks
         * @param {string} marketTickers Comma-separated list of market tickers (maximum 100)
         * @param {number} startTs Start timestamp in Unix seconds
         * @param {number} endTs End timestamp in Unix seconds
         * @param {number} periodInterval Candlestick period interval in minutes
         * @param {boolean} [includeLatestBeforeStart] If true, prepends the latest candlestick available before the start_ts. This synthetic candlestick is created by: 1. Finding the most recent real candlestick before start_ts 2. Projecting it forward to the first period boundary (calculated as the next period interval after start_ts) 3. Setting all OHLC prices to null, and &#x60;previous_price&#x60; to the close price from the real candlestick
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchGetMarketCandlesticks: (marketTickers_1, startTs_1, endTs_1, periodInterval_1, includeLatestBeforeStart_1, ...args_1) => __awaiter(this, [marketTickers_1, startTs_1, endTs_1, periodInterval_1, includeLatestBeforeStart_1, ...args_1], void 0, function* (marketTickers, startTs, endTs, periodInterval, includeLatestBeforeStart, options = {}) {
            // verify required parameter 'marketTickers' is not null or undefined
            (0, common_1.assertParamExists)('batchGetMarketCandlesticks', 'marketTickers', marketTickers);
            // verify required parameter 'startTs' is not null or undefined
            (0, common_1.assertParamExists)('batchGetMarketCandlesticks', 'startTs', startTs);
            // verify required parameter 'endTs' is not null or undefined
            (0, common_1.assertParamExists)('batchGetMarketCandlesticks', 'endTs', endTs);
            // verify required parameter 'periodInterval' is not null or undefined
            (0, common_1.assertParamExists)('batchGetMarketCandlesticks', 'periodInterval', periodInterval);
            const localVarPath = `/markets/candlesticks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (marketTickers !== undefined) {
                localVarQueryParameter['market_tickers'] = marketTickers;
            }
            if (startTs !== undefined) {
                localVarQueryParameter['start_ts'] = startTs;
            }
            if (endTs !== undefined) {
                localVarQueryParameter['end_ts'] = endTs;
            }
            if (periodInterval !== undefined) {
                localVarQueryParameter['period_interval'] = periodInterval;
            }
            if (includeLatestBeforeStart !== undefined) {
                localVarQueryParameter['include_latest_before_start'] = includeLatestBeforeStart;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for getting data about a specific market by its ticker. A market represents a specific binary outcome within an event that users can trade on (e.g., \"Will candidate X win?\"). Markets have yes/no positions, current prices, volume, and settlement rules.
         * @summary Get Market
         * @param {string} ticker Market ticker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarket: (ticker_1, ...args_1) => __awaiter(this, [ticker_1, ...args_1], void 0, function* (ticker, options = {}) {
            // verify required parameter 'ticker' is not null or undefined
            (0, common_1.assertParamExists)('getMarket', 'ticker', ticker);
            const localVarPath = `/markets/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Time period length of each candlestick in minutes. Valid values: 1 (1 minute), 60 (1 hour), 1440 (1 day).
         * @summary Get Market Candlesticks
         * @param {string} seriesTicker Series ticker - the series that contains the target market
         * @param {string} ticker Market ticker - unique identifier for the specific market
         * @param {number} startTs Start timestamp (Unix timestamp). Candlesticks will include those ending on or after this time.
         * @param {number} endTs End timestamp (Unix timestamp). Candlesticks will include those ending on or before this time.
         * @param {GetMarketCandlesticksPeriodIntervalEnum} periodInterval Time period length of each candlestick in minutes. Valid values are 1 (1 minute), 60 (1 hour), or 1440 (1 day).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketCandlesticks: (seriesTicker_1, ticker_1, startTs_1, endTs_1, periodInterval_1, ...args_1) => __awaiter(this, [seriesTicker_1, ticker_1, startTs_1, endTs_1, periodInterval_1, ...args_1], void 0, function* (seriesTicker, ticker, startTs, endTs, periodInterval, options = {}) {
            // verify required parameter 'seriesTicker' is not null or undefined
            (0, common_1.assertParamExists)('getMarketCandlesticks', 'seriesTicker', seriesTicker);
            // verify required parameter 'ticker' is not null or undefined
            (0, common_1.assertParamExists)('getMarketCandlesticks', 'ticker', ticker);
            // verify required parameter 'startTs' is not null or undefined
            (0, common_1.assertParamExists)('getMarketCandlesticks', 'startTs', startTs);
            // verify required parameter 'endTs' is not null or undefined
            (0, common_1.assertParamExists)('getMarketCandlesticks', 'endTs', endTs);
            // verify required parameter 'periodInterval' is not null or undefined
            (0, common_1.assertParamExists)('getMarketCandlesticks', 'periodInterval', periodInterval);
            const localVarPath = `/series/{series_ticker}/markets/{ticker}/candlesticks`
                .replace(`{${"series_ticker"}}`, encodeURIComponent(String(seriesTicker)))
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (startTs !== undefined) {
                localVarQueryParameter['start_ts'] = startTs;
            }
            if (endTs !== undefined) {
                localVarQueryParameter['end_ts'] = endTs;
            }
            if (periodInterval !== undefined) {
                localVarQueryParameter['period_interval'] = periodInterval;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for getting the current order book for a specific market.  The order book shows all active bid orders for both yes and no sides of a binary market. It returns yes bids and no bids only (no asks are returned). This is because in binary markets, a bid for yes at price X is equivalent to an ask for no at price (100-X). For example, a yes bid at 7¢ is the same as a no ask at 93¢, with identical contract sizes.  Each side shows price levels with their corresponding quantities and order counts, organized from best to worst prices.
         * @summary Get Market Orderbook
         * @param {string} ticker Market ticker
         * @param {number} [depth] Depth of the orderbook to retrieve (0 or negative means all levels, 1-100 for specific depth)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketOrderbook: (ticker_1, depth_1, ...args_1) => __awaiter(this, [ticker_1, depth_1, ...args_1], void 0, function* (ticker, depth, options = {}) {
            // verify required parameter 'ticker' is not null or undefined
            (0, common_1.assertParamExists)('getMarketOrderbook', 'ticker', ticker);
            const localVarPath = `/markets/{ticker}/orderbook`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Filter by market status. Possible values: `unopened`, `open`, `closed`, `settled`. Leave empty to return markets with any status.  - Only one `status` filter may be supplied at a time.  - Timestamp filters will be mutually exclusive from other timestamp filters and certain status filters.   | Compatible Timestamp Filters | Additional Status Filters|  |------------------------------|--------------------------|  | min_created_ts, max_created_ts | `unopened`, `open`, *empty* |  | min_close_ts, max_close_ts | `closed`, *empty* |  | min_settled_ts, max_settled_ts | `settled`, *empty* |
         * @summary Get Markets
         * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 1000.
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {string} [eventTicker] Event ticker of desired positions. Multiple event tickers can be provided as a comma-separated list (maximum 10).
         * @param {string} [seriesTicker] Filter by series ticker
         * @param {number} [minCreatedTs] Filter items that created after this Unix timestamp
         * @param {number} [maxCreatedTs] Filter items that created before this Unix timestamp
         * @param {number} [maxCloseTs] Filter items that close before this Unix timestamp
         * @param {number} [minCloseTs] Filter items that close after this Unix timestamp
         * @param {number} [minSettledTs] Filter items that settled after this Unix timestamp
         * @param {number} [maxSettledTs] Filter items that settled before this Unix timestamp
         * @param {GetMarketsStatusEnum} [status] Filter by market status. Leave empty to return markets with any status.
         * @param {string} [tickers] Filter by specific market tickers. Comma-separated list of market tickers to retrieve.
         * @param {GetMarketsMveFilterEnum} [mveFilter] Filter by multivariate events (combos). \&#39;only\&#39; returns only multivariate events, \&#39;exclude\&#39; excludes multivariate events.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarkets: (limit_1, cursor_1, eventTicker_1, seriesTicker_1, minCreatedTs_1, maxCreatedTs_1, maxCloseTs_1, minCloseTs_1, minSettledTs_1, maxSettledTs_1, status_1, tickers_1, mveFilter_1, ...args_1) => __awaiter(this, [limit_1, cursor_1, eventTicker_1, seriesTicker_1, minCreatedTs_1, maxCreatedTs_1, maxCloseTs_1, minCloseTs_1, minSettledTs_1, maxSettledTs_1, status_1, tickers_1, mveFilter_1, ...args_1], void 0, function* (limit, cursor, eventTicker, seriesTicker, minCreatedTs, maxCreatedTs, maxCloseTs, minCloseTs, minSettledTs, maxSettledTs, status, tickers, mveFilter, options = {}) {
            const localVarPath = `/markets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (eventTicker !== undefined) {
                localVarQueryParameter['event_ticker'] = eventTicker;
            }
            if (seriesTicker !== undefined) {
                localVarQueryParameter['series_ticker'] = seriesTicker;
            }
            if (minCreatedTs !== undefined) {
                localVarQueryParameter['min_created_ts'] = minCreatedTs;
            }
            if (maxCreatedTs !== undefined) {
                localVarQueryParameter['max_created_ts'] = maxCreatedTs;
            }
            if (maxCloseTs !== undefined) {
                localVarQueryParameter['max_close_ts'] = maxCloseTs;
            }
            if (minCloseTs !== undefined) {
                localVarQueryParameter['min_close_ts'] = minCloseTs;
            }
            if (minSettledTs !== undefined) {
                localVarQueryParameter['min_settled_ts'] = minSettledTs;
            }
            if (maxSettledTs !== undefined) {
                localVarQueryParameter['max_settled_ts'] = maxSettledTs;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (tickers !== undefined) {
                localVarQueryParameter['tickers'] = tickers;
            }
            if (mveFilter !== undefined) {
                localVarQueryParameter['mve_filter'] = mveFilter;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for getting data about a specific series by its ticker.  A series represents a template for recurring events that follow the same format and rules (e.g., \"Monthly Jobs Report\", \"Weekly Initial Jobless Claims\", \"Daily Weather in NYC\"). Series define the structure, settlement sources, and metadata that will be applied to each recurring event instance within that series.
         * @summary Get Series
         * @param {string} seriesTicker The ticker of the series to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeries: (seriesTicker_1, ...args_1) => __awaiter(this, [seriesTicker_1, ...args_1], void 0, function* (seriesTicker, options = {}) {
            // verify required parameter 'seriesTicker' is not null or undefined
            (0, common_1.assertParamExists)('getSeries', 'seriesTicker', seriesTicker);
            const localVarPath = `/series/{series_ticker}`
                .replace(`{${"series_ticker"}}`, encodeURIComponent(String(seriesTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for getting data about multiple series with specified filters.  A series represents a template for recurring events that follow the same format and rules (e.g., \"Monthly Jobs Report\", \"Weekly Initial Jobless Claims\", \"Daily Weather in NYC\"). This endpoint allows you to browse and discover available series templates by category.
         * @summary Get Series List
         * @param {string} [category]
         * @param {string} [tags]
         * @param {boolean} [includeProductMetadata]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesList: (category_1, tags_1, includeProductMetadata_1, ...args_1) => __awaiter(this, [category_1, tags_1, includeProductMetadata_1, ...args_1], void 0, function* (category, tags, includeProductMetadata, options = {}) {
            const localVarPath = `/series`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }
            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }
            if (includeProductMetadata !== undefined) {
                localVarQueryParameter['include_product_metadata'] = includeProductMetadata;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for getting all trades for all markets.  A trade represents a completed transaction between two users on a specific market. Each trade includes the market ticker, price, quantity, and timestamp information.  This endpoint returns a paginated response. Use the \'limit\' parameter to control page size (1-1000, defaults to 100). The response includes a \'cursor\' field - pass this value in the \'cursor\' parameter of your next request to get the next page. An empty cursor indicates no more pages are available.
         * @summary Get Trades
         * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 1000.
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {string} [ticker] Filter by market ticker
         * @param {number} [minTs] Filter items after this Unix timestamp
         * @param {number} [maxTs] Filter items before this Unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrades: (limit_1, cursor_1, ticker_1, minTs_1, maxTs_1, ...args_1) => __awaiter(this, [limit_1, cursor_1, ticker_1, minTs_1, maxTs_1, ...args_1], void 0, function* (limit, cursor, ticker, minTs, maxTs, options = {}) {
            const localVarPath = `/markets/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }
            if (minTs !== undefined) {
                localVarQueryParameter['min_ts'] = minTs;
            }
            if (maxTs !== undefined) {
                localVarQueryParameter['max_ts'] = maxTs;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.MarketApiAxiosParamCreator = MarketApiAxiosParamCreator;
/**
 * MarketApi - functional programming interface
 */
const MarketApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.MarketApiAxiosParamCreator)(configuration);
    return {
        /**
         * Endpoint for retrieving candlestick data for multiple markets.  - Accepts up to 100 market tickers per request - Returns up to 10,000 candlesticks total across all markets - Returns candlesticks grouped by market_id - Optionally includes a synthetic initial candlestick for price continuity (see `include_latest_before_start` parameter)
         * @summary Batch Get Market Candlesticks
         * @param {string} marketTickers Comma-separated list of market tickers (maximum 100)
         * @param {number} startTs Start timestamp in Unix seconds
         * @param {number} endTs End timestamp in Unix seconds
         * @param {number} periodInterval Candlestick period interval in minutes
         * @param {boolean} [includeLatestBeforeStart] If true, prepends the latest candlestick available before the start_ts. This synthetic candlestick is created by: 1. Finding the most recent real candlestick before start_ts 2. Projecting it forward to the first period boundary (calculated as the next period interval after start_ts) 3. Setting all OHLC prices to null, and &#x60;previous_price&#x60; to the close price from the real candlestick
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchGetMarketCandlesticks(marketTickers, startTs, endTs, periodInterval, includeLatestBeforeStart, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.batchGetMarketCandlesticks(marketTickers, startTs, endTs, periodInterval, includeLatestBeforeStart, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for getting data about a specific market by its ticker. A market represents a specific binary outcome within an event that users can trade on (e.g., \"Will candidate X win?\"). Markets have yes/no positions, current prices, volume, and settlement rules.
         * @summary Get Market
         * @param {string} ticker Market ticker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarket(ticker, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMarket(ticker, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Time period length of each candlestick in minutes. Valid values: 1 (1 minute), 60 (1 hour), 1440 (1 day).
         * @summary Get Market Candlesticks
         * @param {string} seriesTicker Series ticker - the series that contains the target market
         * @param {string} ticker Market ticker - unique identifier for the specific market
         * @param {number} startTs Start timestamp (Unix timestamp). Candlesticks will include those ending on or after this time.
         * @param {number} endTs End timestamp (Unix timestamp). Candlesticks will include those ending on or before this time.
         * @param {GetMarketCandlesticksPeriodIntervalEnum} periodInterval Time period length of each candlestick in minutes. Valid values are 1 (1 minute), 60 (1 hour), or 1440 (1 day).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketCandlesticks(seriesTicker, ticker, startTs, endTs, periodInterval, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMarketCandlesticks(seriesTicker, ticker, startTs, endTs, periodInterval, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for getting the current order book for a specific market.  The order book shows all active bid orders for both yes and no sides of a binary market. It returns yes bids and no bids only (no asks are returned). This is because in binary markets, a bid for yes at price X is equivalent to an ask for no at price (100-X). For example, a yes bid at 7¢ is the same as a no ask at 93¢, with identical contract sizes.  Each side shows price levels with their corresponding quantities and order counts, organized from best to worst prices.
         * @summary Get Market Orderbook
         * @param {string} ticker Market ticker
         * @param {number} [depth] Depth of the orderbook to retrieve (0 or negative means all levels, 1-100 for specific depth)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketOrderbook(ticker, depth, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMarketOrderbook(ticker, depth, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Filter by market status. Possible values: `unopened`, `open`, `closed`, `settled`. Leave empty to return markets with any status.  - Only one `status` filter may be supplied at a time.  - Timestamp filters will be mutually exclusive from other timestamp filters and certain status filters.   | Compatible Timestamp Filters | Additional Status Filters|  |------------------------------|--------------------------|  | min_created_ts, max_created_ts | `unopened`, `open`, *empty* |  | min_close_ts, max_close_ts | `closed`, *empty* |  | min_settled_ts, max_settled_ts | `settled`, *empty* |
         * @summary Get Markets
         * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 1000.
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {string} [eventTicker] Event ticker of desired positions. Multiple event tickers can be provided as a comma-separated list (maximum 10).
         * @param {string} [seriesTicker] Filter by series ticker
         * @param {number} [minCreatedTs] Filter items that created after this Unix timestamp
         * @param {number} [maxCreatedTs] Filter items that created before this Unix timestamp
         * @param {number} [maxCloseTs] Filter items that close before this Unix timestamp
         * @param {number} [minCloseTs] Filter items that close after this Unix timestamp
         * @param {number} [minSettledTs] Filter items that settled after this Unix timestamp
         * @param {number} [maxSettledTs] Filter items that settled before this Unix timestamp
         * @param {GetMarketsStatusEnum} [status] Filter by market status. Leave empty to return markets with any status.
         * @param {string} [tickers] Filter by specific market tickers. Comma-separated list of market tickers to retrieve.
         * @param {GetMarketsMveFilterEnum} [mveFilter] Filter by multivariate events (combos). \&#39;only\&#39; returns only multivariate events, \&#39;exclude\&#39; excludes multivariate events.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarkets(limit, cursor, eventTicker, seriesTicker, minCreatedTs, maxCreatedTs, maxCloseTs, minCloseTs, minSettledTs, maxSettledTs, status, tickers, mveFilter, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMarkets(limit, cursor, eventTicker, seriesTicker, minCreatedTs, maxCreatedTs, maxCloseTs, minCloseTs, minSettledTs, maxSettledTs, status, tickers, mveFilter, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for getting data about a specific series by its ticker.  A series represents a template for recurring events that follow the same format and rules (e.g., \"Monthly Jobs Report\", \"Weekly Initial Jobless Claims\", \"Daily Weather in NYC\"). Series define the structure, settlement sources, and metadata that will be applied to each recurring event instance within that series.
         * @summary Get Series
         * @param {string} seriesTicker The ticker of the series to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeries(seriesTicker, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSeries(seriesTicker, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for getting data about multiple series with specified filters.  A series represents a template for recurring events that follow the same format and rules (e.g., \"Monthly Jobs Report\", \"Weekly Initial Jobless Claims\", \"Daily Weather in NYC\"). This endpoint allows you to browse and discover available series templates by category.
         * @summary Get Series List
         * @param {string} [category]
         * @param {string} [tags]
         * @param {boolean} [includeProductMetadata]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesList(category, tags, includeProductMetadata, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSeriesList(category, tags, includeProductMetadata, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for getting all trades for all markets.  A trade represents a completed transaction between two users on a specific market. Each trade includes the market ticker, price, quantity, and timestamp information.  This endpoint returns a paginated response. Use the \'limit\' parameter to control page size (1-1000, defaults to 100). The response includes a \'cursor\' field - pass this value in the \'cursor\' parameter of your next request to get the next page. An empty cursor indicates no more pages are available.
         * @summary Get Trades
         * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 1000.
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {string} [ticker] Filter by market ticker
         * @param {number} [minTs] Filter items after this Unix timestamp
         * @param {number} [maxTs] Filter items before this Unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrades(limit, cursor, ticker, minTs, maxTs, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTrades(limit, cursor, ticker, minTs, maxTs, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.MarketApiFp = MarketApiFp;
/**
 * MarketApi - factory interface
 */
const MarketApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.MarketApiFp)(configuration);
    return {
        /**
         * Endpoint for retrieving candlestick data for multiple markets.  - Accepts up to 100 market tickers per request - Returns up to 10,000 candlesticks total across all markets - Returns candlesticks grouped by market_id - Optionally includes a synthetic initial candlestick for price continuity (see `include_latest_before_start` parameter)
         * @summary Batch Get Market Candlesticks
         * @param {string} marketTickers Comma-separated list of market tickers (maximum 100)
         * @param {number} startTs Start timestamp in Unix seconds
         * @param {number} endTs End timestamp in Unix seconds
         * @param {number} periodInterval Candlestick period interval in minutes
         * @param {boolean} [includeLatestBeforeStart] If true, prepends the latest candlestick available before the start_ts. This synthetic candlestick is created by: 1. Finding the most recent real candlestick before start_ts 2. Projecting it forward to the first period boundary (calculated as the next period interval after start_ts) 3. Setting all OHLC prices to null, and &#x60;previous_price&#x60; to the close price from the real candlestick
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchGetMarketCandlesticks(marketTickers, startTs, endTs, periodInterval, includeLatestBeforeStart, options) {
            return localVarFp.batchGetMarketCandlesticks(marketTickers, startTs, endTs, periodInterval, includeLatestBeforeStart, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for getting data about a specific market by its ticker. A market represents a specific binary outcome within an event that users can trade on (e.g., \"Will candidate X win?\"). Markets have yes/no positions, current prices, volume, and settlement rules.
         * @summary Get Market
         * @param {string} ticker Market ticker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarket(ticker, options) {
            return localVarFp.getMarket(ticker, options).then((request) => request(axios, basePath));
        },
        /**
         * Time period length of each candlestick in minutes. Valid values: 1 (1 minute), 60 (1 hour), 1440 (1 day).
         * @summary Get Market Candlesticks
         * @param {string} seriesTicker Series ticker - the series that contains the target market
         * @param {string} ticker Market ticker - unique identifier for the specific market
         * @param {number} startTs Start timestamp (Unix timestamp). Candlesticks will include those ending on or after this time.
         * @param {number} endTs End timestamp (Unix timestamp). Candlesticks will include those ending on or before this time.
         * @param {GetMarketCandlesticksPeriodIntervalEnum} periodInterval Time period length of each candlestick in minutes. Valid values are 1 (1 minute), 60 (1 hour), or 1440 (1 day).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketCandlesticks(seriesTicker, ticker, startTs, endTs, periodInterval, options) {
            return localVarFp.getMarketCandlesticks(seriesTicker, ticker, startTs, endTs, periodInterval, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for getting the current order book for a specific market.  The order book shows all active bid orders for both yes and no sides of a binary market. It returns yes bids and no bids only (no asks are returned). This is because in binary markets, a bid for yes at price X is equivalent to an ask for no at price (100-X). For example, a yes bid at 7¢ is the same as a no ask at 93¢, with identical contract sizes.  Each side shows price levels with their corresponding quantities and order counts, organized from best to worst prices.
         * @summary Get Market Orderbook
         * @param {string} ticker Market ticker
         * @param {number} [depth] Depth of the orderbook to retrieve (0 or negative means all levels, 1-100 for specific depth)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketOrderbook(ticker, depth, options) {
            return localVarFp.getMarketOrderbook(ticker, depth, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter by market status. Possible values: `unopened`, `open`, `closed`, `settled`. Leave empty to return markets with any status.  - Only one `status` filter may be supplied at a time.  - Timestamp filters will be mutually exclusive from other timestamp filters and certain status filters.   | Compatible Timestamp Filters | Additional Status Filters|  |------------------------------|--------------------------|  | min_created_ts, max_created_ts | `unopened`, `open`, *empty* |  | min_close_ts, max_close_ts | `closed`, *empty* |  | min_settled_ts, max_settled_ts | `settled`, *empty* |
         * @summary Get Markets
         * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 1000.
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {string} [eventTicker] Event ticker of desired positions. Multiple event tickers can be provided as a comma-separated list (maximum 10).
         * @param {string} [seriesTicker] Filter by series ticker
         * @param {number} [minCreatedTs] Filter items that created after this Unix timestamp
         * @param {number} [maxCreatedTs] Filter items that created before this Unix timestamp
         * @param {number} [maxCloseTs] Filter items that close before this Unix timestamp
         * @param {number} [minCloseTs] Filter items that close after this Unix timestamp
         * @param {number} [minSettledTs] Filter items that settled after this Unix timestamp
         * @param {number} [maxSettledTs] Filter items that settled before this Unix timestamp
         * @param {GetMarketsStatusEnum} [status] Filter by market status. Leave empty to return markets with any status.
         * @param {string} [tickers] Filter by specific market tickers. Comma-separated list of market tickers to retrieve.
         * @param {GetMarketsMveFilterEnum} [mveFilter] Filter by multivariate events (combos). \&#39;only\&#39; returns only multivariate events, \&#39;exclude\&#39; excludes multivariate events.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarkets(limit, cursor, eventTicker, seriesTicker, minCreatedTs, maxCreatedTs, maxCloseTs, minCloseTs, minSettledTs, maxSettledTs, status, tickers, mveFilter, options) {
            return localVarFp.getMarkets(limit, cursor, eventTicker, seriesTicker, minCreatedTs, maxCreatedTs, maxCloseTs, minCloseTs, minSettledTs, maxSettledTs, status, tickers, mveFilter, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for getting data about a specific series by its ticker.  A series represents a template for recurring events that follow the same format and rules (e.g., \"Monthly Jobs Report\", \"Weekly Initial Jobless Claims\", \"Daily Weather in NYC\"). Series define the structure, settlement sources, and metadata that will be applied to each recurring event instance within that series.
         * @summary Get Series
         * @param {string} seriesTicker The ticker of the series to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeries(seriesTicker, options) {
            return localVarFp.getSeries(seriesTicker, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for getting data about multiple series with specified filters.  A series represents a template for recurring events that follow the same format and rules (e.g., \"Monthly Jobs Report\", \"Weekly Initial Jobless Claims\", \"Daily Weather in NYC\"). This endpoint allows you to browse and discover available series templates by category.
         * @summary Get Series List
         * @param {string} [category]
         * @param {string} [tags]
         * @param {boolean} [includeProductMetadata]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesList(category, tags, includeProductMetadata, options) {
            return localVarFp.getSeriesList(category, tags, includeProductMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for getting all trades for all markets.  A trade represents a completed transaction between two users on a specific market. Each trade includes the market ticker, price, quantity, and timestamp information.  This endpoint returns a paginated response. Use the \'limit\' parameter to control page size (1-1000, defaults to 100). The response includes a \'cursor\' field - pass this value in the \'cursor\' parameter of your next request to get the next page. An empty cursor indicates no more pages are available.
         * @summary Get Trades
         * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 1000.
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {string} [ticker] Filter by market ticker
         * @param {number} [minTs] Filter items after this Unix timestamp
         * @param {number} [maxTs] Filter items before this Unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrades(limit, cursor, ticker, minTs, maxTs, options) {
            return localVarFp.getTrades(limit, cursor, ticker, minTs, maxTs, options).then((request) => request(axios, basePath));
        },
    };
};
exports.MarketApiFactory = MarketApiFactory;
/**
 * MarketApi - object-oriented interface
 */
class MarketApi extends base_1.BaseAPI {
    /**
     * Endpoint for retrieving candlestick data for multiple markets.  - Accepts up to 100 market tickers per request - Returns up to 10,000 candlesticks total across all markets - Returns candlesticks grouped by market_id - Optionally includes a synthetic initial candlestick for price continuity (see `include_latest_before_start` parameter)
     * @summary Batch Get Market Candlesticks
     * @param {string} marketTickers Comma-separated list of market tickers (maximum 100)
     * @param {number} startTs Start timestamp in Unix seconds
     * @param {number} endTs End timestamp in Unix seconds
     * @param {number} periodInterval Candlestick period interval in minutes
     * @param {boolean} [includeLatestBeforeStart] If true, prepends the latest candlestick available before the start_ts. This synthetic candlestick is created by: 1. Finding the most recent real candlestick before start_ts 2. Projecting it forward to the first period boundary (calculated as the next period interval after start_ts) 3. Setting all OHLC prices to null, and &#x60;previous_price&#x60; to the close price from the real candlestick
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    batchGetMarketCandlesticks(marketTickers, startTs, endTs, periodInterval, includeLatestBeforeStart, options) {
        return (0, exports.MarketApiFp)(this.configuration).batchGetMarketCandlesticks(marketTickers, startTs, endTs, periodInterval, includeLatestBeforeStart, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for getting data about a specific market by its ticker. A market represents a specific binary outcome within an event that users can trade on (e.g., \"Will candidate X win?\"). Markets have yes/no positions, current prices, volume, and settlement rules.
     * @summary Get Market
     * @param {string} ticker Market ticker
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarket(ticker, options) {
        return (0, exports.MarketApiFp)(this.configuration).getMarket(ticker, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Time period length of each candlestick in minutes. Valid values: 1 (1 minute), 60 (1 hour), 1440 (1 day).
     * @summary Get Market Candlesticks
     * @param {string} seriesTicker Series ticker - the series that contains the target market
     * @param {string} ticker Market ticker - unique identifier for the specific market
     * @param {number} startTs Start timestamp (Unix timestamp). Candlesticks will include those ending on or after this time.
     * @param {number} endTs End timestamp (Unix timestamp). Candlesticks will include those ending on or before this time.
     * @param {GetMarketCandlesticksPeriodIntervalEnum} periodInterval Time period length of each candlestick in minutes. Valid values are 1 (1 minute), 60 (1 hour), or 1440 (1 day).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketCandlesticks(seriesTicker, ticker, startTs, endTs, periodInterval, options) {
        return (0, exports.MarketApiFp)(this.configuration).getMarketCandlesticks(seriesTicker, ticker, startTs, endTs, periodInterval, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for getting the current order book for a specific market.  The order book shows all active bid orders for both yes and no sides of a binary market. It returns yes bids and no bids only (no asks are returned). This is because in binary markets, a bid for yes at price X is equivalent to an ask for no at price (100-X). For example, a yes bid at 7¢ is the same as a no ask at 93¢, with identical contract sizes.  Each side shows price levels with their corresponding quantities and order counts, organized from best to worst prices.
     * @summary Get Market Orderbook
     * @param {string} ticker Market ticker
     * @param {number} [depth] Depth of the orderbook to retrieve (0 or negative means all levels, 1-100 for specific depth)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketOrderbook(ticker, depth, options) {
        return (0, exports.MarketApiFp)(this.configuration).getMarketOrderbook(ticker, depth, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Filter by market status. Possible values: `unopened`, `open`, `closed`, `settled`. Leave empty to return markets with any status.  - Only one `status` filter may be supplied at a time.  - Timestamp filters will be mutually exclusive from other timestamp filters and certain status filters.   | Compatible Timestamp Filters | Additional Status Filters|  |------------------------------|--------------------------|  | min_created_ts, max_created_ts | `unopened`, `open`, *empty* |  | min_close_ts, max_close_ts | `closed`, *empty* |  | min_settled_ts, max_settled_ts | `settled`, *empty* |
     * @summary Get Markets
     * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 1000.
     * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
     * @param {string} [eventTicker] Event ticker of desired positions. Multiple event tickers can be provided as a comma-separated list (maximum 10).
     * @param {string} [seriesTicker] Filter by series ticker
     * @param {number} [minCreatedTs] Filter items that created after this Unix timestamp
     * @param {number} [maxCreatedTs] Filter items that created before this Unix timestamp
     * @param {number} [maxCloseTs] Filter items that close before this Unix timestamp
     * @param {number} [minCloseTs] Filter items that close after this Unix timestamp
     * @param {number} [minSettledTs] Filter items that settled after this Unix timestamp
     * @param {number} [maxSettledTs] Filter items that settled before this Unix timestamp
     * @param {GetMarketsStatusEnum} [status] Filter by market status. Leave empty to return markets with any status.
     * @param {string} [tickers] Filter by specific market tickers. Comma-separated list of market tickers to retrieve.
     * @param {GetMarketsMveFilterEnum} [mveFilter] Filter by multivariate events (combos). \&#39;only\&#39; returns only multivariate events, \&#39;exclude\&#39; excludes multivariate events.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarkets(limit, cursor, eventTicker, seriesTicker, minCreatedTs, maxCreatedTs, maxCloseTs, minCloseTs, minSettledTs, maxSettledTs, status, tickers, mveFilter, options) {
        return (0, exports.MarketApiFp)(this.configuration).getMarkets(limit, cursor, eventTicker, seriesTicker, minCreatedTs, maxCreatedTs, maxCloseTs, minCloseTs, minSettledTs, maxSettledTs, status, tickers, mveFilter, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for getting data about a specific series by its ticker.  A series represents a template for recurring events that follow the same format and rules (e.g., \"Monthly Jobs Report\", \"Weekly Initial Jobless Claims\", \"Daily Weather in NYC\"). Series define the structure, settlement sources, and metadata that will be applied to each recurring event instance within that series.
     * @summary Get Series
     * @param {string} seriesTicker The ticker of the series to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSeries(seriesTicker, options) {
        return (0, exports.MarketApiFp)(this.configuration).getSeries(seriesTicker, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for getting data about multiple series with specified filters.  A series represents a template for recurring events that follow the same format and rules (e.g., \"Monthly Jobs Report\", \"Weekly Initial Jobless Claims\", \"Daily Weather in NYC\"). This endpoint allows you to browse and discover available series templates by category.
     * @summary Get Series List
     * @param {string} [category]
     * @param {string} [tags]
     * @param {boolean} [includeProductMetadata]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSeriesList(category, tags, includeProductMetadata, options) {
        return (0, exports.MarketApiFp)(this.configuration).getSeriesList(category, tags, includeProductMetadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for getting all trades for all markets.  A trade represents a completed transaction between two users on a specific market. Each trade includes the market ticker, price, quantity, and timestamp information.  This endpoint returns a paginated response. Use the \'limit\' parameter to control page size (1-1000, defaults to 100). The response includes a \'cursor\' field - pass this value in the \'cursor\' parameter of your next request to get the next page. An empty cursor indicates no more pages are available.
     * @summary Get Trades
     * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 1000.
     * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
     * @param {string} [ticker] Filter by market ticker
     * @param {number} [minTs] Filter items after this Unix timestamp
     * @param {number} [maxTs] Filter items before this Unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTrades(limit, cursor, ticker, minTs, maxTs, options) {
        return (0, exports.MarketApiFp)(this.configuration).getTrades(limit, cursor, ticker, minTs, maxTs, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.MarketApi = MarketApi;
exports.GetMarketCandlesticksPeriodIntervalEnum = {
    NUMBER_1: 1,
    NUMBER_60: 60,
    NUMBER_1440: 1440
};
exports.GetMarketsStatusEnum = {
    Unopened: 'unopened',
    Open: 'open',
    Paused: 'paused',
    Closed: 'closed',
    Settled: 'settled'
};
exports.GetMarketsMveFilterEnum = {
    Only: 'only',
    Exclude: 'exclude'
};
