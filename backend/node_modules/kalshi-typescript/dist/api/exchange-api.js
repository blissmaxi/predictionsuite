"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Kalshi Trade API Manual Endpoints
 * Manually defined OpenAPI spec for endpoints being migrated to spec-first approach
 *
 * The version of the OpenAPI document: 3.4.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExchangeApi = exports.ExchangeApiFactory = exports.ExchangeApiFp = exports.ExchangeApiAxiosParamCreator = void 0;
const axios_1 = require("axios");
// URLSearchParams not necessarily used
// @ts-ignore
const url_1 = require("url");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * ExchangeApi - axios parameter creator
 */
const ExchangeApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Endpoint for getting all exchange-wide announcements.
         * @summary Get Exchange Announcements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeAnnouncements: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/exchange/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for getting the exchange schedule.
         * @summary Get Exchange Schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeSchedule: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/exchange/schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for getting the exchange status.
         * @summary Get Exchange Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeStatus: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/exchange/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Series Fee Changes
         * @param {string} [seriesTicker]
         * @param {boolean} [showHistorical]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesFeeChanges: (seriesTicker_1, showHistorical_1, ...args_1) => __awaiter(this, [seriesTicker_1, showHistorical_1, ...args_1], void 0, function* (seriesTicker, showHistorical, options = {}) {
            const localVarPath = `/series/fee_changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (seriesTicker !== undefined) {
                localVarQueryParameter['series_ticker'] = seriesTicker;
            }
            if (showHistorical !== undefined) {
                localVarQueryParameter['show_historical'] = showHistorical;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  There is typically a short delay before exchange events are reflected in the API endpoints. Whenever possible, combine API responses to PUT/POST/DELETE requests with websocket data to obtain the most accurate view of the exchange state. This endpoint provides an approximate indication of when the data from the following endpoints was last validated: GetBalance, GetOrder(s), GetFills, GetPositions
         * @summary Get User Data Timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDataTimestamp: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/exchange/user_data_timestamp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ExchangeApiAxiosParamCreator = ExchangeApiAxiosParamCreator;
/**
 * ExchangeApi - functional programming interface
 */
const ExchangeApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ExchangeApiAxiosParamCreator)(configuration);
    return {
        /**
         *  Endpoint for getting all exchange-wide announcements.
         * @summary Get Exchange Announcements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeAnnouncements(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getExchangeAnnouncements(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for getting the exchange schedule.
         * @summary Get Exchange Schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeSchedule(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getExchangeSchedule(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for getting the exchange status.
         * @summary Get Exchange Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeStatus(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getExchangeStatus(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get Series Fee Changes
         * @param {string} [seriesTicker]
         * @param {boolean} [showHistorical]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesFeeChanges(seriesTicker, showHistorical, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSeriesFeeChanges(seriesTicker, showHistorical, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  There is typically a short delay before exchange events are reflected in the API endpoints. Whenever possible, combine API responses to PUT/POST/DELETE requests with websocket data to obtain the most accurate view of the exchange state. This endpoint provides an approximate indication of when the data from the following endpoints was last validated: GetBalance, GetOrder(s), GetFills, GetPositions
         * @summary Get User Data Timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDataTimestamp(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserDataTimestamp(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.ExchangeApiFp = ExchangeApiFp;
/**
 * ExchangeApi - factory interface
 */
const ExchangeApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ExchangeApiFp)(configuration);
    return {
        /**
         *  Endpoint for getting all exchange-wide announcements.
         * @summary Get Exchange Announcements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeAnnouncements(options) {
            return localVarFp.getExchangeAnnouncements(options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for getting the exchange schedule.
         * @summary Get Exchange Schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeSchedule(options) {
            return localVarFp.getExchangeSchedule(options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for getting the exchange status.
         * @summary Get Exchange Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeStatus(options) {
            return localVarFp.getExchangeStatus(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Series Fee Changes
         * @param {string} [seriesTicker]
         * @param {boolean} [showHistorical]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesFeeChanges(seriesTicker, showHistorical, options) {
            return localVarFp.getSeriesFeeChanges(seriesTicker, showHistorical, options).then((request) => request(axios, basePath));
        },
        /**
         *  There is typically a short delay before exchange events are reflected in the API endpoints. Whenever possible, combine API responses to PUT/POST/DELETE requests with websocket data to obtain the most accurate view of the exchange state. This endpoint provides an approximate indication of when the data from the following endpoints was last validated: GetBalance, GetOrder(s), GetFills, GetPositions
         * @summary Get User Data Timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDataTimestamp(options) {
            return localVarFp.getUserDataTimestamp(options).then((request) => request(axios, basePath));
        },
    };
};
exports.ExchangeApiFactory = ExchangeApiFactory;
/**
 * ExchangeApi - object-oriented interface
 */
class ExchangeApi extends base_1.BaseAPI {
    /**
     *  Endpoint for getting all exchange-wide announcements.
     * @summary Get Exchange Announcements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExchangeAnnouncements(options) {
        return (0, exports.ExchangeApiFp)(this.configuration).getExchangeAnnouncements(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for getting the exchange schedule.
     * @summary Get Exchange Schedule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExchangeSchedule(options) {
        return (0, exports.ExchangeApiFp)(this.configuration).getExchangeSchedule(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for getting the exchange status.
     * @summary Get Exchange Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExchangeStatus(options) {
        return (0, exports.ExchangeApiFp)(this.configuration).getExchangeStatus(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Series Fee Changes
     * @param {string} [seriesTicker]
     * @param {boolean} [showHistorical]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSeriesFeeChanges(seriesTicker, showHistorical, options) {
        return (0, exports.ExchangeApiFp)(this.configuration).getSeriesFeeChanges(seriesTicker, showHistorical, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  There is typically a short delay before exchange events are reflected in the API endpoints. Whenever possible, combine API responses to PUT/POST/DELETE requests with websocket data to obtain the most accurate view of the exchange state. This endpoint provides an approximate indication of when the data from the following endpoints was last validated: GetBalance, GetOrder(s), GetFills, GetPositions
     * @summary Get User Data Timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserDataTimestamp(options) {
        return (0, exports.ExchangeApiFp)(this.configuration).getUserDataTimestamp(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ExchangeApi = ExchangeApi;
