"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Kalshi Trade API Manual Endpoints
 * Manually defined OpenAPI spec for endpoints being migrated to spec-first approach
 *
 * The version of the OpenAPI document: 3.4.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetMarketCandlesticksByEventPeriodIntervalEnum = exports.GetEventsStatusEnum = exports.GetEventForecastPercentilesHistoryPeriodIntervalEnum = exports.EventsApi = exports.EventsApiFactory = exports.EventsApiFp = exports.EventsApiAxiosParamCreator = void 0;
const axios_1 = require("axios");
// URLSearchParams not necessarily used
// @ts-ignore
const url_1 = require("url");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("../common");
// @ts-ignore
const base_1 = require("../base");
/**
 * EventsApi - axios parameter creator
 */
const EventsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Endpoint for getting data about an event by its ticker.  An event represents a real-world occurrence that can be traded on, such as an election, sports game, or economic indicator release. Events contain one or more markets where users can place trades on different outcomes.
         * @summary Get Event
         * @param {string} eventTicker Event ticker
         * @param {boolean} [withNestedMarkets] If true, markets are included within the event object. If false (default), markets are returned as a separate top-level field in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent: (eventTicker_1, withNestedMarkets_1, ...args_1) => __awaiter(this, [eventTicker_1, withNestedMarkets_1, ...args_1], void 0, function* (eventTicker, withNestedMarkets, options = {}) {
            // verify required parameter 'eventTicker' is not null or undefined
            (0, common_1.assertParamExists)('getEvent', 'eventTicker', eventTicker);
            const localVarPath = `/events/{event_ticker}`
                .replace(`{${"event_ticker"}}`, encodeURIComponent(String(eventTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (withNestedMarkets !== undefined) {
                localVarQueryParameter['with_nested_markets'] = withNestedMarkets;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Endpoint for getting the historical raw and formatted forecast numbers for an event at specific percentiles.
         * @summary Get Event Forecast Percentile History
         * @param {string} ticker The event ticker
         * @param {string} seriesTicker The series ticker
         * @param {Array<number>} percentiles Array of percentile values to retrieve (0-10000, max 10 values)
         * @param {number} startTs Start timestamp for the range
         * @param {number} endTs End timestamp for the range
         * @param {GetEventForecastPercentilesHistoryPeriodIntervalEnum} periodInterval Specifies the length of each forecast period, in minutes. 0 for 5-second intervals, or 1, 60, or 1440 for minute-based intervals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventForecastPercentilesHistory: (ticker_1, seriesTicker_1, percentiles_1, startTs_1, endTs_1, periodInterval_1, ...args_1) => __awaiter(this, [ticker_1, seriesTicker_1, percentiles_1, startTs_1, endTs_1, periodInterval_1, ...args_1], void 0, function* (ticker, seriesTicker, percentiles, startTs, endTs, periodInterval, options = {}) {
            // verify required parameter 'ticker' is not null or undefined
            (0, common_1.assertParamExists)('getEventForecastPercentilesHistory', 'ticker', ticker);
            // verify required parameter 'seriesTicker' is not null or undefined
            (0, common_1.assertParamExists)('getEventForecastPercentilesHistory', 'seriesTicker', seriesTicker);
            // verify required parameter 'percentiles' is not null or undefined
            (0, common_1.assertParamExists)('getEventForecastPercentilesHistory', 'percentiles', percentiles);
            // verify required parameter 'startTs' is not null or undefined
            (0, common_1.assertParamExists)('getEventForecastPercentilesHistory', 'startTs', startTs);
            // verify required parameter 'endTs' is not null or undefined
            (0, common_1.assertParamExists)('getEventForecastPercentilesHistory', 'endTs', endTs);
            // verify required parameter 'periodInterval' is not null or undefined
            (0, common_1.assertParamExists)('getEventForecastPercentilesHistory', 'periodInterval', periodInterval);
            const localVarPath = `/series/{series_ticker}/events/{ticker}/forecast_percentile_history`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)))
                .replace(`{${"series_ticker"}}`, encodeURIComponent(String(seriesTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            if (percentiles) {
                localVarQueryParameter['percentiles'] = percentiles;
            }
            if (startTs !== undefined) {
                localVarQueryParameter['start_ts'] = startTs;
            }
            if (endTs !== undefined) {
                localVarQueryParameter['end_ts'] = endTs;
            }
            if (periodInterval !== undefined) {
                localVarQueryParameter['period_interval'] = periodInterval;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for getting metadata about an event by its ticker.  Returns only the metadata information for an event.
         * @summary Get Event Metadata
         * @param {string} eventTicker Event ticker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMetadata: (eventTicker_1, ...args_1) => __awaiter(this, [eventTicker_1, ...args_1], void 0, function* (eventTicker, options = {}) {
            // verify required parameter 'eventTicker' is not null or undefined
            (0, common_1.assertParamExists)('getEventMetadata', 'eventTicker', eventTicker);
            const localVarPath = `/events/{event_ticker}/metadata`
                .replace(`{${"event_ticker"}}`, encodeURIComponent(String(eventTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all events. This endpoint excludes multivariate events. To retrieve multivariate events, use the GET /events/multivariate endpoint.
         * @summary Get Events
         * @param {number} [limit] Parameter to specify the number of results per page. Defaults to 200. Maximum value is 200.
         * @param {string} [cursor] Parameter to specify the pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {boolean} [withNestedMarkets] Parameter to specify if nested markets should be included in the response. When true, each event will include a \&#39;markets\&#39; field containing a list of Market objects associated with that event.
         * @param {boolean} [withMilestones] If true, includes related milestones as a field alongside events.
         * @param {GetEventsStatusEnum} [status] Filter by event status. Possible values are \&#39;open\&#39;, \&#39;closed\&#39;, \&#39;settled\&#39;. Leave empty to return events with any status.
         * @param {string} [seriesTicker] Filter by series ticker
         * @param {number} [minCloseTs] Filter events with at least one market with close timestamp greater than this Unix timestamp (in seconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents: (limit_1, cursor_1, withNestedMarkets_1, withMilestones_1, status_1, seriesTicker_1, minCloseTs_1, ...args_1) => __awaiter(this, [limit_1, cursor_1, withNestedMarkets_1, withMilestones_1, status_1, seriesTicker_1, minCloseTs_1, ...args_1], void 0, function* (limit, cursor, withNestedMarkets, withMilestones, status, seriesTicker, minCloseTs, options = {}) {
            const localVarPath = `/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (withNestedMarkets !== undefined) {
                localVarQueryParameter['with_nested_markets'] = withNestedMarkets;
            }
            if (withMilestones !== undefined) {
                localVarQueryParameter['with_milestones'] = withMilestones;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (seriesTicker !== undefined) {
                localVarQueryParameter['series_ticker'] = seriesTicker;
            }
            if (minCloseTs !== undefined) {
                localVarQueryParameter['min_close_ts'] = minCloseTs;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  End-point for returning aggregated data across all markets corresponding to an event.
         * @summary Get Event Candlesticks
         * @param {string} ticker The event ticker
         * @param {string} seriesTicker The series ticker
         * @param {number} startTs Start timestamp for the range
         * @param {number} endTs End timestamp for the range
         * @param {GetMarketCandlesticksByEventPeriodIntervalEnum} periodInterval Specifies the length of each candlestick period, in minutes. Must be one minute, one hour, or one day.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketCandlesticksByEvent: (ticker_1, seriesTicker_1, startTs_1, endTs_1, periodInterval_1, ...args_1) => __awaiter(this, [ticker_1, seriesTicker_1, startTs_1, endTs_1, periodInterval_1, ...args_1], void 0, function* (ticker, seriesTicker, startTs, endTs, periodInterval, options = {}) {
            // verify required parameter 'ticker' is not null or undefined
            (0, common_1.assertParamExists)('getMarketCandlesticksByEvent', 'ticker', ticker);
            // verify required parameter 'seriesTicker' is not null or undefined
            (0, common_1.assertParamExists)('getMarketCandlesticksByEvent', 'seriesTicker', seriesTicker);
            // verify required parameter 'startTs' is not null or undefined
            (0, common_1.assertParamExists)('getMarketCandlesticksByEvent', 'startTs', startTs);
            // verify required parameter 'endTs' is not null or undefined
            (0, common_1.assertParamExists)('getMarketCandlesticksByEvent', 'endTs', endTs);
            // verify required parameter 'periodInterval' is not null or undefined
            (0, common_1.assertParamExists)('getMarketCandlesticksByEvent', 'periodInterval', periodInterval);
            const localVarPath = `/series/{series_ticker}/events/{ticker}/candlesticks`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)))
                .replace(`{${"series_ticker"}}`, encodeURIComponent(String(seriesTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (startTs !== undefined) {
                localVarQueryParameter['start_ts'] = startTs;
            }
            if (endTs !== undefined) {
                localVarQueryParameter['end_ts'] = endTs;
            }
            if (periodInterval !== undefined) {
                localVarQueryParameter['period_interval'] = periodInterval;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve multivariate (combo) events. These are dynamically created events from multivariate event collections. Supports filtering by series and collection ticker.
         * @summary Get Multivariate Events
         * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 200.
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results.
         * @param {string} [seriesTicker] Filter by series ticker
         * @param {string} [collectionTicker] Filter events by collection ticker. Returns only multivariate events belonging to the specified collection. Cannot be used together with series_ticker.
         * @param {boolean} [withNestedMarkets] Parameter to specify if nested markets should be included in the response. When true, each event will include a \&#39;markets\&#39; field containing a list of Market objects associated with that event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultivariateEvents: (limit_1, cursor_1, seriesTicker_1, collectionTicker_1, withNestedMarkets_1, ...args_1) => __awaiter(this, [limit_1, cursor_1, seriesTicker_1, collectionTicker_1, withNestedMarkets_1, ...args_1], void 0, function* (limit, cursor, seriesTicker, collectionTicker, withNestedMarkets, options = {}) {
            const localVarPath = `/events/multivariate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new url_1.URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (seriesTicker !== undefined) {
                localVarQueryParameter['series_ticker'] = seriesTicker;
            }
            if (collectionTicker !== undefined) {
                localVarQueryParameter['collection_ticker'] = collectionTicker;
            }
            if (withNestedMarkets !== undefined) {
                localVarQueryParameter['with_nested_markets'] = withNestedMarkets;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.EventsApiAxiosParamCreator = EventsApiAxiosParamCreator;
/**
 * EventsApi - functional programming interface
 */
const EventsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.EventsApiAxiosParamCreator)(configuration);
    return {
        /**
         *  Endpoint for getting data about an event by its ticker.  An event represents a real-world occurrence that can be traded on, such as an election, sports game, or economic indicator release. Events contain one or more markets where users can place trades on different outcomes.
         * @summary Get Event
         * @param {string} eventTicker Event ticker
         * @param {boolean} [withNestedMarkets] If true, markets are included within the event object. If false (default), markets are returned as a separate top-level field in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(eventTicker, withNestedMarkets, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEvent(eventTicker, withNestedMarkets, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Endpoint for getting the historical raw and formatted forecast numbers for an event at specific percentiles.
         * @summary Get Event Forecast Percentile History
         * @param {string} ticker The event ticker
         * @param {string} seriesTicker The series ticker
         * @param {Array<number>} percentiles Array of percentile values to retrieve (0-10000, max 10 values)
         * @param {number} startTs Start timestamp for the range
         * @param {number} endTs End timestamp for the range
         * @param {GetEventForecastPercentilesHistoryPeriodIntervalEnum} periodInterval Specifies the length of each forecast period, in minutes. 0 for 5-second intervals, or 1, 60, or 1440 for minute-based intervals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventForecastPercentilesHistory(ticker, seriesTicker, percentiles, startTs, endTs, periodInterval, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEventForecastPercentilesHistory(ticker, seriesTicker, percentiles, startTs, endTs, periodInterval, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for getting metadata about an event by its ticker.  Returns only the metadata information for an event.
         * @summary Get Event Metadata
         * @param {string} eventTicker Event ticker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMetadata(eventTicker, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEventMetadata(eventTicker, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all events. This endpoint excludes multivariate events. To retrieve multivariate events, use the GET /events/multivariate endpoint.
         * @summary Get Events
         * @param {number} [limit] Parameter to specify the number of results per page. Defaults to 200. Maximum value is 200.
         * @param {string} [cursor] Parameter to specify the pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {boolean} [withNestedMarkets] Parameter to specify if nested markets should be included in the response. When true, each event will include a \&#39;markets\&#39; field containing a list of Market objects associated with that event.
         * @param {boolean} [withMilestones] If true, includes related milestones as a field alongside events.
         * @param {GetEventsStatusEnum} [status] Filter by event status. Possible values are \&#39;open\&#39;, \&#39;closed\&#39;, \&#39;settled\&#39;. Leave empty to return events with any status.
         * @param {string} [seriesTicker] Filter by series ticker
         * @param {number} [minCloseTs] Filter events with at least one market with close timestamp greater than this Unix timestamp (in seconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(limit, cursor, withNestedMarkets, withMilestones, status, seriesTicker, minCloseTs, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEvents(limit, cursor, withNestedMarkets, withMilestones, status, seriesTicker, minCloseTs, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  End-point for returning aggregated data across all markets corresponding to an event.
         * @summary Get Event Candlesticks
         * @param {string} ticker The event ticker
         * @param {string} seriesTicker The series ticker
         * @param {number} startTs Start timestamp for the range
         * @param {number} endTs End timestamp for the range
         * @param {GetMarketCandlesticksByEventPeriodIntervalEnum} periodInterval Specifies the length of each candlestick period, in minutes. Must be one minute, one hour, or one day.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketCandlesticksByEvent(ticker, seriesTicker, startTs, endTs, periodInterval, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMarketCandlesticksByEvent(ticker, seriesTicker, startTs, endTs, periodInterval, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Retrieve multivariate (combo) events. These are dynamically created events from multivariate event collections. Supports filtering by series and collection ticker.
         * @summary Get Multivariate Events
         * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 200.
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results.
         * @param {string} [seriesTicker] Filter by series ticker
         * @param {string} [collectionTicker] Filter events by collection ticker. Returns only multivariate events belonging to the specified collection. Cannot be used together with series_ticker.
         * @param {boolean} [withNestedMarkets] Parameter to specify if nested markets should be included in the response. When true, each event will include a \&#39;markets\&#39; field containing a list of Market objects associated with that event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultivariateEvents(limit, cursor, seriesTicker, collectionTicker, withNestedMarkets, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMultivariateEvents(limit, cursor, seriesTicker, collectionTicker, withNestedMarkets, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
exports.EventsApiFp = EventsApiFp;
/**
 * EventsApi - factory interface
 */
const EventsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.EventsApiFp)(configuration);
    return {
        /**
         *  Endpoint for getting data about an event by its ticker.  An event represents a real-world occurrence that can be traded on, such as an election, sports game, or economic indicator release. Events contain one or more markets where users can place trades on different outcomes.
         * @summary Get Event
         * @param {string} eventTicker Event ticker
         * @param {boolean} [withNestedMarkets] If true, markets are included within the event object. If false (default), markets are returned as a separate top-level field in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(eventTicker, withNestedMarkets, options) {
            return localVarFp.getEvent(eventTicker, withNestedMarkets, options).then((request) => request(axios, basePath));
        },
        /**
         * Endpoint for getting the historical raw and formatted forecast numbers for an event at specific percentiles.
         * @summary Get Event Forecast Percentile History
         * @param {string} ticker The event ticker
         * @param {string} seriesTicker The series ticker
         * @param {Array<number>} percentiles Array of percentile values to retrieve (0-10000, max 10 values)
         * @param {number} startTs Start timestamp for the range
         * @param {number} endTs End timestamp for the range
         * @param {GetEventForecastPercentilesHistoryPeriodIntervalEnum} periodInterval Specifies the length of each forecast period, in minutes. 0 for 5-second intervals, or 1, 60, or 1440 for minute-based intervals.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventForecastPercentilesHistory(ticker, seriesTicker, percentiles, startTs, endTs, periodInterval, options) {
            return localVarFp.getEventForecastPercentilesHistory(ticker, seriesTicker, percentiles, startTs, endTs, periodInterval, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for getting metadata about an event by its ticker.  Returns only the metadata information for an event.
         * @summary Get Event Metadata
         * @param {string} eventTicker Event ticker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventMetadata(eventTicker, options) {
            return localVarFp.getEventMetadata(eventTicker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all events. This endpoint excludes multivariate events. To retrieve multivariate events, use the GET /events/multivariate endpoint.
         * @summary Get Events
         * @param {number} [limit] Parameter to specify the number of results per page. Defaults to 200. Maximum value is 200.
         * @param {string} [cursor] Parameter to specify the pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {boolean} [withNestedMarkets] Parameter to specify if nested markets should be included in the response. When true, each event will include a \&#39;markets\&#39; field containing a list of Market objects associated with that event.
         * @param {boolean} [withMilestones] If true, includes related milestones as a field alongside events.
         * @param {GetEventsStatusEnum} [status] Filter by event status. Possible values are \&#39;open\&#39;, \&#39;closed\&#39;, \&#39;settled\&#39;. Leave empty to return events with any status.
         * @param {string} [seriesTicker] Filter by series ticker
         * @param {number} [minCloseTs] Filter events with at least one market with close timestamp greater than this Unix timestamp (in seconds).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvents(limit, cursor, withNestedMarkets, withMilestones, status, seriesTicker, minCloseTs, options) {
            return localVarFp.getEvents(limit, cursor, withNestedMarkets, withMilestones, status, seriesTicker, minCloseTs, options).then((request) => request(axios, basePath));
        },
        /**
         *  End-point for returning aggregated data across all markets corresponding to an event.
         * @summary Get Event Candlesticks
         * @param {string} ticker The event ticker
         * @param {string} seriesTicker The series ticker
         * @param {number} startTs Start timestamp for the range
         * @param {number} endTs End timestamp for the range
         * @param {GetMarketCandlesticksByEventPeriodIntervalEnum} periodInterval Specifies the length of each candlestick period, in minutes. Must be one minute, one hour, or one day.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketCandlesticksByEvent(ticker, seriesTicker, startTs, endTs, periodInterval, options) {
            return localVarFp.getMarketCandlesticksByEvent(ticker, seriesTicker, startTs, endTs, periodInterval, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve multivariate (combo) events. These are dynamically created events from multivariate event collections. Supports filtering by series and collection ticker.
         * @summary Get Multivariate Events
         * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 200.
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results.
         * @param {string} [seriesTicker] Filter by series ticker
         * @param {string} [collectionTicker] Filter events by collection ticker. Returns only multivariate events belonging to the specified collection. Cannot be used together with series_ticker.
         * @param {boolean} [withNestedMarkets] Parameter to specify if nested markets should be included in the response. When true, each event will include a \&#39;markets\&#39; field containing a list of Market objects associated with that event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultivariateEvents(limit, cursor, seriesTicker, collectionTicker, withNestedMarkets, options) {
            return localVarFp.getMultivariateEvents(limit, cursor, seriesTicker, collectionTicker, withNestedMarkets, options).then((request) => request(axios, basePath));
        },
    };
};
exports.EventsApiFactory = EventsApiFactory;
/**
 * EventsApi - object-oriented interface
 */
class EventsApi extends base_1.BaseAPI {
    /**
     *  Endpoint for getting data about an event by its ticker.  An event represents a real-world occurrence that can be traded on, such as an election, sports game, or economic indicator release. Events contain one or more markets where users can place trades on different outcomes.
     * @summary Get Event
     * @param {string} eventTicker Event ticker
     * @param {boolean} [withNestedMarkets] If true, markets are included within the event object. If false (default), markets are returned as a separate top-level field in the response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEvent(eventTicker, withNestedMarkets, options) {
        return (0, exports.EventsApiFp)(this.configuration).getEvent(eventTicker, withNestedMarkets, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Endpoint for getting the historical raw and formatted forecast numbers for an event at specific percentiles.
     * @summary Get Event Forecast Percentile History
     * @param {string} ticker The event ticker
     * @param {string} seriesTicker The series ticker
     * @param {Array<number>} percentiles Array of percentile values to retrieve (0-10000, max 10 values)
     * @param {number} startTs Start timestamp for the range
     * @param {number} endTs End timestamp for the range
     * @param {GetEventForecastPercentilesHistoryPeriodIntervalEnum} periodInterval Specifies the length of each forecast period, in minutes. 0 for 5-second intervals, or 1, 60, or 1440 for minute-based intervals.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventForecastPercentilesHistory(ticker, seriesTicker, percentiles, startTs, endTs, periodInterval, options) {
        return (0, exports.EventsApiFp)(this.configuration).getEventForecastPercentilesHistory(ticker, seriesTicker, percentiles, startTs, endTs, periodInterval, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for getting metadata about an event by its ticker.  Returns only the metadata information for an event.
     * @summary Get Event Metadata
     * @param {string} eventTicker Event ticker
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEventMetadata(eventTicker, options) {
        return (0, exports.EventsApiFp)(this.configuration).getEventMetadata(eventTicker, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all events. This endpoint excludes multivariate events. To retrieve multivariate events, use the GET /events/multivariate endpoint.
     * @summary Get Events
     * @param {number} [limit] Parameter to specify the number of results per page. Defaults to 200. Maximum value is 200.
     * @param {string} [cursor] Parameter to specify the pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
     * @param {boolean} [withNestedMarkets] Parameter to specify if nested markets should be included in the response. When true, each event will include a \&#39;markets\&#39; field containing a list of Market objects associated with that event.
     * @param {boolean} [withMilestones] If true, includes related milestones as a field alongside events.
     * @param {GetEventsStatusEnum} [status] Filter by event status. Possible values are \&#39;open\&#39;, \&#39;closed\&#39;, \&#39;settled\&#39;. Leave empty to return events with any status.
     * @param {string} [seriesTicker] Filter by series ticker
     * @param {number} [minCloseTs] Filter events with at least one market with close timestamp greater than this Unix timestamp (in seconds).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEvents(limit, cursor, withNestedMarkets, withMilestones, status, seriesTicker, minCloseTs, options) {
        return (0, exports.EventsApiFp)(this.configuration).getEvents(limit, cursor, withNestedMarkets, withMilestones, status, seriesTicker, minCloseTs, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  End-point for returning aggregated data across all markets corresponding to an event.
     * @summary Get Event Candlesticks
     * @param {string} ticker The event ticker
     * @param {string} seriesTicker The series ticker
     * @param {number} startTs Start timestamp for the range
     * @param {number} endTs End timestamp for the range
     * @param {GetMarketCandlesticksByEventPeriodIntervalEnum} periodInterval Specifies the length of each candlestick period, in minutes. Must be one minute, one hour, or one day.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketCandlesticksByEvent(ticker, seriesTicker, startTs, endTs, periodInterval, options) {
        return (0, exports.EventsApiFp)(this.configuration).getMarketCandlesticksByEvent(ticker, seriesTicker, startTs, endTs, periodInterval, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve multivariate (combo) events. These are dynamically created events from multivariate event collections. Supports filtering by series and collection ticker.
     * @summary Get Multivariate Events
     * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 200.
     * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results.
     * @param {string} [seriesTicker] Filter by series ticker
     * @param {string} [collectionTicker] Filter events by collection ticker. Returns only multivariate events belonging to the specified collection. Cannot be used together with series_ticker.
     * @param {boolean} [withNestedMarkets] Parameter to specify if nested markets should be included in the response. When true, each event will include a \&#39;markets\&#39; field containing a list of Market objects associated with that event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultivariateEvents(limit, cursor, seriesTicker, collectionTicker, withNestedMarkets, options) {
        return (0, exports.EventsApiFp)(this.configuration).getMultivariateEvents(limit, cursor, seriesTicker, collectionTicker, withNestedMarkets, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.EventsApi = EventsApi;
exports.GetEventForecastPercentilesHistoryPeriodIntervalEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_60: 60,
    NUMBER_1440: 1440
};
exports.GetEventsStatusEnum = {
    Open: 'open',
    Closed: 'closed',
    Settled: 'settled'
};
exports.GetMarketCandlesticksByEventPeriodIntervalEnum = {
    NUMBER_1: 1,
    NUMBER_60: 60,
    NUMBER_1440: 1440
};
