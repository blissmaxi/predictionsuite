/* tslint:disable */
/* eslint-disable */
/**
 * Kalshi Trade API Manual Endpoints
 * Manually defined OpenAPI spec for endpoints being migrated to spec-first approach
 *
 * The version of the OpenAPI document: 3.4.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, BaseAPI } from '../base';
/**
 * CommunicationsApi - axios parameter creator
 */
export const CommunicationsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Endpoint for accepting a quote. This will require the quoter to confirm
         * @summary Accept Quote
         * @param {string} quoteId Quote ID
         * @param {AcceptQuoteRequest} acceptQuoteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptQuote: (quoteId_1, acceptQuoteRequest_1, ...args_1) => __awaiter(this, [quoteId_1, acceptQuoteRequest_1, ...args_1], void 0, function* (quoteId, acceptQuoteRequest, options = {}) {
            // verify required parameter 'quoteId' is not null or undefined
            assertParamExists('acceptQuote', 'quoteId', quoteId);
            // verify required parameter 'acceptQuoteRequest' is not null or undefined
            assertParamExists('acceptQuote', 'acceptQuoteRequest', acceptQuoteRequest);
            const localVarPath = `/communications/quotes/{quote_id}/accept`
                .replace(`{${"quote_id"}}`, encodeURIComponent(String(quoteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(acceptQuoteRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for confirming a quote. This will start a timer for order execution
         * @summary Confirm Quote
         * @param {string} quoteId Quote ID
         * @param {object} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmQuote: (quoteId_1, body_1, ...args_1) => __awaiter(this, [quoteId_1, body_1, ...args_1], void 0, function* (quoteId, body, options = {}) {
            // verify required parameter 'quoteId' is not null or undefined
            assertParamExists('confirmQuote', 'quoteId', quoteId);
            const localVarPath = `/communications/quotes/{quote_id}/confirm`
                .replace(`{${"quote_id"}}`, encodeURIComponent(String(quoteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for creating a quote in response to an RFQ
         * @summary Create Quote
         * @param {CreateQuoteRequest} createQuoteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuote: (createQuoteRequest_1, ...args_1) => __awaiter(this, [createQuoteRequest_1, ...args_1], void 0, function* (createQuoteRequest, options = {}) {
            // verify required parameter 'createQuoteRequest' is not null or undefined
            assertParamExists('createQuote', 'createQuoteRequest', createQuoteRequest);
            const localVarPath = `/communications/quotes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(createQuoteRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for creating a new RFQ. You can have a maximum of 100 open RFQs at a time.
         * @summary Create RFQ
         * @param {CreateRFQRequest} createRFQRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRFQ: (createRFQRequest_1, ...args_1) => __awaiter(this, [createRFQRequest_1, ...args_1], void 0, function* (createRFQRequest, options = {}) {
            // verify required parameter 'createRFQRequest' is not null or undefined
            assertParamExists('createRFQ', 'createRFQRequest', createRFQRequest);
            const localVarPath = `/communications/rfqs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(createRFQRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for deleting a quote, which means it can no longer be accepted.
         * @summary Delete Quote
         * @param {string} quoteId Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuote: (quoteId_1, ...args_1) => __awaiter(this, [quoteId_1, ...args_1], void 0, function* (quoteId, options = {}) {
            // verify required parameter 'quoteId' is not null or undefined
            assertParamExists('deleteQuote', 'quoteId', quoteId);
            const localVarPath = `/communications/quotes/{quote_id}`
                .replace(`{${"quote_id"}}`, encodeURIComponent(String(quoteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for deleting an RFQ by ID
         * @summary Delete RFQ
         * @param {string} rfqId RFQ ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRFQ: (rfqId_1, ...args_1) => __awaiter(this, [rfqId_1, ...args_1], void 0, function* (rfqId, options = {}) {
            // verify required parameter 'rfqId' is not null or undefined
            assertParamExists('deleteRFQ', 'rfqId', rfqId);
            const localVarPath = `/communications/rfqs/{rfq_id}`
                .replace(`{${"rfq_id"}}`, encodeURIComponent(String(rfqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for getting the communications ID of the logged-in user.
         * @summary Get Communications ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommunicationsID: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/communications/id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for getting a particular quote
         * @summary Get Quote
         * @param {string} quoteId Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuote: (quoteId_1, ...args_1) => __awaiter(this, [quoteId_1, ...args_1], void 0, function* (quoteId, options = {}) {
            // verify required parameter 'quoteId' is not null or undefined
            assertParamExists('getQuote', 'quoteId', quoteId);
            const localVarPath = `/communications/quotes/{quote_id}`
                .replace(`{${"quote_id"}}`, encodeURIComponent(String(quoteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for getting quotes
         * @summary Get Quotes
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {string} [eventTicker] Event ticker of desired positions. Multiple event tickers can be provided as a comma-separated list (maximum 10).
         * @param {string} [marketTicker] Filter by market ticker
         * @param {number} [limit] Parameter to specify the number of results per page. Defaults to 500.
         * @param {string} [status] Filter quotes by status
         * @param {string} [quoteCreatorUserId] Filter quotes by quote creator user ID
         * @param {string} [rfqCreatorUserId] Filter quotes by RFQ creator user ID
         * @param {string} [rfqCreatorSubtraderId] Filter quotes by RFQ creator subtrader ID (FCM members only)
         * @param {string} [rfqId] Filter quotes by RFQ ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuotes: (cursor_1, eventTicker_1, marketTicker_1, limit_1, status_1, quoteCreatorUserId_1, rfqCreatorUserId_1, rfqCreatorSubtraderId_1, rfqId_1, ...args_1) => __awaiter(this, [cursor_1, eventTicker_1, marketTicker_1, limit_1, status_1, quoteCreatorUserId_1, rfqCreatorUserId_1, rfqCreatorSubtraderId_1, rfqId_1, ...args_1], void 0, function* (cursor, eventTicker, marketTicker, limit, status, quoteCreatorUserId, rfqCreatorUserId, rfqCreatorSubtraderId, rfqId, options = {}) {
            const localVarPath = `/communications/quotes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (eventTicker !== undefined) {
                localVarQueryParameter['event_ticker'] = eventTicker;
            }
            if (marketTicker !== undefined) {
                localVarQueryParameter['market_ticker'] = marketTicker;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (quoteCreatorUserId !== undefined) {
                localVarQueryParameter['quote_creator_user_id'] = quoteCreatorUserId;
            }
            if (rfqCreatorUserId !== undefined) {
                localVarQueryParameter['rfq_creator_user_id'] = rfqCreatorUserId;
            }
            if (rfqCreatorSubtraderId !== undefined) {
                localVarQueryParameter['rfq_creator_subtrader_id'] = rfqCreatorSubtraderId;
            }
            if (rfqId !== undefined) {
                localVarQueryParameter['rfq_id'] = rfqId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for getting a single RFQ by id
         * @summary Get RFQ
         * @param {string} rfqId RFQ ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRFQ: (rfqId_1, ...args_1) => __awaiter(this, [rfqId_1, ...args_1], void 0, function* (rfqId, options = {}) {
            // verify required parameter 'rfqId' is not null or undefined
            assertParamExists('getRFQ', 'rfqId', rfqId);
            const localVarPath = `/communications/rfqs/{rfq_id}`
                .replace(`{${"rfq_id"}}`, encodeURIComponent(String(rfqId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for getting RFQs
         * @summary Get RFQs
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {string} [eventTicker] Event ticker of desired positions. Multiple event tickers can be provided as a comma-separated list (maximum 10).
         * @param {string} [marketTicker] Filter by market ticker
         * @param {number} [limit] Parameter to specify the number of results per page. Defaults to 100.
         * @param {string} [status] Filter RFQs by status
         * @param {string} [creatorUserId] Filter RFQs by creator user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRFQs: (cursor_1, eventTicker_1, marketTicker_1, limit_1, status_1, creatorUserId_1, ...args_1) => __awaiter(this, [cursor_1, eventTicker_1, marketTicker_1, limit_1, status_1, creatorUserId_1, ...args_1], void 0, function* (cursor, eventTicker, marketTicker, limit, status, creatorUserId, options = {}) {
            const localVarPath = `/communications/rfqs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication kalshiAccessSignature required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-SIGNATURE", configuration);
            // authentication kalshiAccessKey required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-KEY", configuration);
            // authentication kalshiAccessTimestamp required
            yield setApiKeyToObject(localVarHeaderParameter, "KALSHI-ACCESS-TIMESTAMP", configuration);
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (eventTicker !== undefined) {
                localVarQueryParameter['event_ticker'] = eventTicker;
            }
            if (marketTicker !== undefined) {
                localVarQueryParameter['market_ticker'] = marketTicker;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (creatorUserId !== undefined) {
                localVarQueryParameter['creator_user_id'] = creatorUserId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * CommunicationsApi - functional programming interface
 */
export const CommunicationsApiFp = function (configuration) {
    const localVarAxiosParamCreator = CommunicationsApiAxiosParamCreator(configuration);
    return {
        /**
         *  Endpoint for accepting a quote. This will require the quoter to confirm
         * @summary Accept Quote
         * @param {string} quoteId Quote ID
         * @param {AcceptQuoteRequest} acceptQuoteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptQuote(quoteId, acceptQuoteRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.acceptQuote(quoteId, acceptQuoteRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for confirming a quote. This will start a timer for order execution
         * @summary Confirm Quote
         * @param {string} quoteId Quote ID
         * @param {object} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmQuote(quoteId, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.confirmQuote(quoteId, body, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for creating a quote in response to an RFQ
         * @summary Create Quote
         * @param {CreateQuoteRequest} createQuoteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuote(createQuoteRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createQuote(createQuoteRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for creating a new RFQ. You can have a maximum of 100 open RFQs at a time.
         * @summary Create RFQ
         * @param {CreateRFQRequest} createRFQRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRFQ(createRFQRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createRFQ(createRFQRequest, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for deleting a quote, which means it can no longer be accepted.
         * @summary Delete Quote
         * @param {string} quoteId Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuote(quoteId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteQuote(quoteId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for deleting an RFQ by ID
         * @summary Delete RFQ
         * @param {string} rfqId RFQ ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRFQ(rfqId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteRFQ(rfqId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for getting the communications ID of the logged-in user.
         * @summary Get Communications ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommunicationsID(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCommunicationsID(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for getting a particular quote
         * @summary Get Quote
         * @param {string} quoteId Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuote(quoteId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getQuote(quoteId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for getting quotes
         * @summary Get Quotes
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {string} [eventTicker] Event ticker of desired positions. Multiple event tickers can be provided as a comma-separated list (maximum 10).
         * @param {string} [marketTicker] Filter by market ticker
         * @param {number} [limit] Parameter to specify the number of results per page. Defaults to 500.
         * @param {string} [status] Filter quotes by status
         * @param {string} [quoteCreatorUserId] Filter quotes by quote creator user ID
         * @param {string} [rfqCreatorUserId] Filter quotes by RFQ creator user ID
         * @param {string} [rfqCreatorSubtraderId] Filter quotes by RFQ creator subtrader ID (FCM members only)
         * @param {string} [rfqId] Filter quotes by RFQ ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuotes(cursor, eventTicker, marketTicker, limit, status, quoteCreatorUserId, rfqCreatorUserId, rfqCreatorSubtraderId, rfqId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getQuotes(cursor, eventTicker, marketTicker, limit, status, quoteCreatorUserId, rfqCreatorUserId, rfqCreatorSubtraderId, rfqId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for getting a single RFQ by id
         * @summary Get RFQ
         * @param {string} rfqId RFQ ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRFQ(rfqId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRFQ(rfqId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for getting RFQs
         * @summary Get RFQs
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {string} [eventTicker] Event ticker of desired positions. Multiple event tickers can be provided as a comma-separated list (maximum 10).
         * @param {string} [marketTicker] Filter by market ticker
         * @param {number} [limit] Parameter to specify the number of results per page. Defaults to 100.
         * @param {string} [status] Filter RFQs by status
         * @param {string} [creatorUserId] Filter RFQs by creator user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRFQs(cursor, eventTicker, marketTicker, limit, status, creatorUserId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRFQs(cursor, eventTicker, marketTicker, limit, status, creatorUserId, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * CommunicationsApi - factory interface
 */
export const CommunicationsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = CommunicationsApiFp(configuration);
    return {
        /**
         *  Endpoint for accepting a quote. This will require the quoter to confirm
         * @summary Accept Quote
         * @param {string} quoteId Quote ID
         * @param {AcceptQuoteRequest} acceptQuoteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptQuote(quoteId, acceptQuoteRequest, options) {
            return localVarFp.acceptQuote(quoteId, acceptQuoteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for confirming a quote. This will start a timer for order execution
         * @summary Confirm Quote
         * @param {string} quoteId Quote ID
         * @param {object} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmQuote(quoteId, body, options) {
            return localVarFp.confirmQuote(quoteId, body, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for creating a quote in response to an RFQ
         * @summary Create Quote
         * @param {CreateQuoteRequest} createQuoteRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuote(createQuoteRequest, options) {
            return localVarFp.createQuote(createQuoteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for creating a new RFQ. You can have a maximum of 100 open RFQs at a time.
         * @summary Create RFQ
         * @param {CreateRFQRequest} createRFQRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRFQ(createRFQRequest, options) {
            return localVarFp.createRFQ(createRFQRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for deleting a quote, which means it can no longer be accepted.
         * @summary Delete Quote
         * @param {string} quoteId Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuote(quoteId, options) {
            return localVarFp.deleteQuote(quoteId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for deleting an RFQ by ID
         * @summary Delete RFQ
         * @param {string} rfqId RFQ ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRFQ(rfqId, options) {
            return localVarFp.deleteRFQ(rfqId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for getting the communications ID of the logged-in user.
         * @summary Get Communications ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommunicationsID(options) {
            return localVarFp.getCommunicationsID(options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for getting a particular quote
         * @summary Get Quote
         * @param {string} quoteId Quote ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuote(quoteId, options) {
            return localVarFp.getQuote(quoteId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for getting quotes
         * @summary Get Quotes
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {string} [eventTicker] Event ticker of desired positions. Multiple event tickers can be provided as a comma-separated list (maximum 10).
         * @param {string} [marketTicker] Filter by market ticker
         * @param {number} [limit] Parameter to specify the number of results per page. Defaults to 500.
         * @param {string} [status] Filter quotes by status
         * @param {string} [quoteCreatorUserId] Filter quotes by quote creator user ID
         * @param {string} [rfqCreatorUserId] Filter quotes by RFQ creator user ID
         * @param {string} [rfqCreatorSubtraderId] Filter quotes by RFQ creator subtrader ID (FCM members only)
         * @param {string} [rfqId] Filter quotes by RFQ ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuotes(cursor, eventTicker, marketTicker, limit, status, quoteCreatorUserId, rfqCreatorUserId, rfqCreatorSubtraderId, rfqId, options) {
            return localVarFp.getQuotes(cursor, eventTicker, marketTicker, limit, status, quoteCreatorUserId, rfqCreatorUserId, rfqCreatorSubtraderId, rfqId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for getting a single RFQ by id
         * @summary Get RFQ
         * @param {string} rfqId RFQ ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRFQ(rfqId, options) {
            return localVarFp.getRFQ(rfqId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for getting RFQs
         * @summary Get RFQs
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {string} [eventTicker] Event ticker of desired positions. Multiple event tickers can be provided as a comma-separated list (maximum 10).
         * @param {string} [marketTicker] Filter by market ticker
         * @param {number} [limit] Parameter to specify the number of results per page. Defaults to 100.
         * @param {string} [status] Filter RFQs by status
         * @param {string} [creatorUserId] Filter RFQs by creator user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRFQs(cursor, eventTicker, marketTicker, limit, status, creatorUserId, options) {
            return localVarFp.getRFQs(cursor, eventTicker, marketTicker, limit, status, creatorUserId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CommunicationsApi - object-oriented interface
 */
export class CommunicationsApi extends BaseAPI {
    /**
     *  Endpoint for accepting a quote. This will require the quoter to confirm
     * @summary Accept Quote
     * @param {string} quoteId Quote ID
     * @param {AcceptQuoteRequest} acceptQuoteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    acceptQuote(quoteId, acceptQuoteRequest, options) {
        return CommunicationsApiFp(this.configuration).acceptQuote(quoteId, acceptQuoteRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for confirming a quote. This will start a timer for order execution
     * @summary Confirm Quote
     * @param {string} quoteId Quote ID
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirmQuote(quoteId, body, options) {
        return CommunicationsApiFp(this.configuration).confirmQuote(quoteId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for creating a quote in response to an RFQ
     * @summary Create Quote
     * @param {CreateQuoteRequest} createQuoteRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQuote(createQuoteRequest, options) {
        return CommunicationsApiFp(this.configuration).createQuote(createQuoteRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for creating a new RFQ. You can have a maximum of 100 open RFQs at a time.
     * @summary Create RFQ
     * @param {CreateRFQRequest} createRFQRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRFQ(createRFQRequest, options) {
        return CommunicationsApiFp(this.configuration).createRFQ(createRFQRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for deleting a quote, which means it can no longer be accepted.
     * @summary Delete Quote
     * @param {string} quoteId Quote ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQuote(quoteId, options) {
        return CommunicationsApiFp(this.configuration).deleteQuote(quoteId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for deleting an RFQ by ID
     * @summary Delete RFQ
     * @param {string} rfqId RFQ ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRFQ(rfqId, options) {
        return CommunicationsApiFp(this.configuration).deleteRFQ(rfqId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for getting the communications ID of the logged-in user.
     * @summary Get Communications ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCommunicationsID(options) {
        return CommunicationsApiFp(this.configuration).getCommunicationsID(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for getting a particular quote
     * @summary Get Quote
     * @param {string} quoteId Quote ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQuote(quoteId, options) {
        return CommunicationsApiFp(this.configuration).getQuote(quoteId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for getting quotes
     * @summary Get Quotes
     * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
     * @param {string} [eventTicker] Event ticker of desired positions. Multiple event tickers can be provided as a comma-separated list (maximum 10).
     * @param {string} [marketTicker] Filter by market ticker
     * @param {number} [limit] Parameter to specify the number of results per page. Defaults to 500.
     * @param {string} [status] Filter quotes by status
     * @param {string} [quoteCreatorUserId] Filter quotes by quote creator user ID
     * @param {string} [rfqCreatorUserId] Filter quotes by RFQ creator user ID
     * @param {string} [rfqCreatorSubtraderId] Filter quotes by RFQ creator subtrader ID (FCM members only)
     * @param {string} [rfqId] Filter quotes by RFQ ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQuotes(cursor, eventTicker, marketTicker, limit, status, quoteCreatorUserId, rfqCreatorUserId, rfqCreatorSubtraderId, rfqId, options) {
        return CommunicationsApiFp(this.configuration).getQuotes(cursor, eventTicker, marketTicker, limit, status, quoteCreatorUserId, rfqCreatorUserId, rfqCreatorSubtraderId, rfqId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for getting a single RFQ by id
     * @summary Get RFQ
     * @param {string} rfqId RFQ ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRFQ(rfqId, options) {
        return CommunicationsApiFp(this.configuration).getRFQ(rfqId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for getting RFQs
     * @summary Get RFQs
     * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
     * @param {string} [eventTicker] Event ticker of desired positions. Multiple event tickers can be provided as a comma-separated list (maximum 10).
     * @param {string} [marketTicker] Filter by market ticker
     * @param {number} [limit] Parameter to specify the number of results per page. Defaults to 100.
     * @param {string} [status] Filter RFQs by status
     * @param {string} [creatorUserId] Filter RFQs by creator user ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRFQs(cursor, eventTicker, marketTicker, limit, status, creatorUserId, options) {
        return CommunicationsApiFp(this.configuration).getRFQs(cursor, eventTicker, marketTicker, limit, status, creatorUserId, options).then((request) => request(this.axios, this.basePath));
    }
}
