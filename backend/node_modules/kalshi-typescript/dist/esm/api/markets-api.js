/* tslint:disable */
/* eslint-disable */
/**
 * Kalshi Trading API
 * Complete API for the Kalshi trading platform including all handlers for SDK generation
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: support@kalshi.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setBearerAuthToObject, setSearchParams, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, BaseAPI } from '../base';
/**
 * MarketsApi - axios parameter creator
 */
export const MarketsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get a single market by its ticker.  A market represents a specific binary outcome within an event that users can trade on (e.g., \"Will candidate X win?\"). Markets have yes/no positions, current prices, volume, and settlement rules.
         * @summary Get Market
         * @param {string} ticker Market ticker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarket: (ticker_1, ...args_1) => __awaiter(this, [ticker_1, ...args_1], void 0, function* (ticker, options = {}) {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getMarket', 'ticker', ticker);
            const localVarPath = `/markets/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get candlestick data for a market within a series
         * @summary Get Market Candlesticks
         * @param {string} ticker The series ticker
         * @param {string} marketTicker The market ticker
         * @param {number} [startTs] Start timestamp for the range
         * @param {number} [endTs] End timestamp for the range
         * @param {string} [periodInterval] Period interval for candlesticks (e.g., 1m, 5m, 1h, 1d)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketCandlesticks: (ticker_1, marketTicker_1, startTs_1, endTs_1, periodInterval_1, ...args_1) => __awaiter(this, [ticker_1, marketTicker_1, startTs_1, endTs_1, periodInterval_1, ...args_1], void 0, function* (ticker, marketTicker, startTs, endTs, periodInterval, options = {}) {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getMarketCandlesticks', 'ticker', ticker);
            // verify required parameter 'marketTicker' is not null or undefined
            assertParamExists('getMarketCandlesticks', 'marketTicker', marketTicker);
            const localVarPath = `/series/{ticker}/markets/{market_ticker}/candlesticks`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)))
                .replace(`{${"market_ticker"}}`, encodeURIComponent(String(marketTicker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (startTs !== undefined) {
                localVarQueryParameter['start_ts'] = startTs;
            }
            if (endTs !== undefined) {
                localVarQueryParameter['end_ts'] = endTs;
            }
            if (periodInterval !== undefined) {
                localVarQueryParameter['period_interval'] = periodInterval;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get the orderbook for a market
         * @summary Get Market Orderbook
         * @param {string} ticker Market ticker
         * @param {number} [depth] Depth of the orderbook to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketOrderbook: (ticker_1, depth_1, ...args_1) => __awaiter(this, [ticker_1, depth_1, ...args_1], void 0, function* (ticker, depth, options = {}) {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getMarketOrderbook', 'ticker', ticker);
            const localVarPath = `/markets/{ticker}/orderbook`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List and discover markets on Kalshi.  A market represents a specific binary outcome within an event that users can trade on (e.g., \"Will candidate X win?\"). Markets have yes/no positions, current prices, volume, and settlement rules.  This endpoint returns a paginated response. Use the \'limit\' parameter to control page size (1-1000, defaults to 100). The response includes a \'cursor\' field - pass this value in the \'cursor\' parameter of your next request to get the next page. An empty cursor indicates no more pages are available.
         * @summary Get Markets
         * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 1000.
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {string} [eventTicker] Filter by event ticker
         * @param {string} [seriesTicker] Filter by series ticker
         * @param {number} [maxCloseTs] Filter items that close before this Unix timestamp
         * @param {number} [minCloseTs] Filter items that close after this Unix timestamp
         * @param {string} [status] Filter by market status. Comma-separated list. Possible values are \&#39;initialized\&#39;, \&#39;open\&#39;, \&#39;closed\&#39;, \&#39;settled\&#39;, \&#39;determined\&#39;. Note that the API accepts \&#39;open\&#39; for filtering but returns \&#39;active\&#39; in the response. Leave empty to return markets with any status.
         * @param {string} [tickers] Filter by specific market tickers. Comma-separated list of market tickers to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarkets: (limit_1, cursor_1, eventTicker_1, seriesTicker_1, maxCloseTs_1, minCloseTs_1, status_1, tickers_1, ...args_1) => __awaiter(this, [limit_1, cursor_1, eventTicker_1, seriesTicker_1, maxCloseTs_1, minCloseTs_1, status_1, tickers_1, ...args_1], void 0, function* (limit, cursor, eventTicker, seriesTicker, maxCloseTs, minCloseTs, status, tickers, options = {}) {
            const localVarPath = `/markets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication bearerAuth required
            // http bearer authentication required
            yield setBearerAuthToObject(localVarHeaderParameter, configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (eventTicker !== undefined) {
                localVarQueryParameter['event_ticker'] = eventTicker;
            }
            if (seriesTicker !== undefined) {
                localVarQueryParameter['series_ticker'] = seriesTicker;
            }
            if (maxCloseTs !== undefined) {
                localVarQueryParameter['max_close_ts'] = maxCloseTs;
            }
            if (minCloseTs !== undefined) {
                localVarQueryParameter['min_close_ts'] = minCloseTs;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (tickers !== undefined) {
                localVarQueryParameter['tickers'] = tickers;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get all trades for all markets.  A trade represents a completed transaction between two users on a specific market. Each trade includes the market ticker, price, quantity, and timestamp information.  This endpoint returns a paginated response. Use the \'limit\' parameter to control page size (1-1000, defaults to 100). The response includes a \'cursor\' field - pass this value in the \'cursor\' parameter of your next request to get the next page. An empty cursor indicates no more pages are available.
         * @summary Get Trades
         * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 1000.
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {string} [ticker] Filter by market ticker
         * @param {number} [minTs] Filter items after this Unix timestamp
         * @param {number} [maxTs] Filter items before this Unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrades: (limit_1, cursor_1, ticker_1, minTs_1, maxTs_1, ...args_1) => __awaiter(this, [limit_1, cursor_1, ticker_1, minTs_1, maxTs_1, ...args_1], void 0, function* (limit, cursor, ticker, minTs, maxTs, options = {}) {
            const localVarPath = `/markets/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }
            if (minTs !== undefined) {
                localVarQueryParameter['min_ts'] = minTs;
            }
            if (maxTs !== undefined) {
                localVarQueryParameter['max_ts'] = maxTs;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * MarketsApi - functional programming interface
 */
export const MarketsApiFp = function (configuration) {
    const localVarAxiosParamCreator = MarketsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get a single market by its ticker.  A market represents a specific binary outcome within an event that users can trade on (e.g., \"Will candidate X win?\"). Markets have yes/no positions, current prices, volume, and settlement rules.
         * @summary Get Market
         * @param {string} ticker Market ticker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarket(ticker, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMarket(ticker, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get candlestick data for a market within a series
         * @summary Get Market Candlesticks
         * @param {string} ticker The series ticker
         * @param {string} marketTicker The market ticker
         * @param {number} [startTs] Start timestamp for the range
         * @param {number} [endTs] End timestamp for the range
         * @param {string} [periodInterval] Period interval for candlesticks (e.g., 1m, 5m, 1h, 1d)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketCandlesticks(ticker, marketTicker, startTs, endTs, periodInterval, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMarketCandlesticks(ticker, marketTicker, startTs, endTs, periodInterval, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get the orderbook for a market
         * @summary Get Market Orderbook
         * @param {string} ticker Market ticker
         * @param {number} [depth] Depth of the orderbook to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketOrderbook(ticker, depth, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMarketOrderbook(ticker, depth, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * List and discover markets on Kalshi.  A market represents a specific binary outcome within an event that users can trade on (e.g., \"Will candidate X win?\"). Markets have yes/no positions, current prices, volume, and settlement rules.  This endpoint returns a paginated response. Use the \'limit\' parameter to control page size (1-1000, defaults to 100). The response includes a \'cursor\' field - pass this value in the \'cursor\' parameter of your next request to get the next page. An empty cursor indicates no more pages are available.
         * @summary Get Markets
         * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 1000.
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {string} [eventTicker] Filter by event ticker
         * @param {string} [seriesTicker] Filter by series ticker
         * @param {number} [maxCloseTs] Filter items that close before this Unix timestamp
         * @param {number} [minCloseTs] Filter items that close after this Unix timestamp
         * @param {string} [status] Filter by market status. Comma-separated list. Possible values are \&#39;initialized\&#39;, \&#39;open\&#39;, \&#39;closed\&#39;, \&#39;settled\&#39;, \&#39;determined\&#39;. Note that the API accepts \&#39;open\&#39; for filtering but returns \&#39;active\&#39; in the response. Leave empty to return markets with any status.
         * @param {string} [tickers] Filter by specific market tickers. Comma-separated list of market tickers to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarkets(limit, cursor, eventTicker, seriesTicker, maxCloseTs, minCloseTs, status, tickers, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getMarkets(limit, cursor, eventTicker, seriesTicker, maxCloseTs, minCloseTs, status, tickers, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         * Get all trades for all markets.  A trade represents a completed transaction between two users on a specific market. Each trade includes the market ticker, price, quantity, and timestamp information.  This endpoint returns a paginated response. Use the \'limit\' parameter to control page size (1-1000, defaults to 100). The response includes a \'cursor\' field - pass this value in the \'cursor\' parameter of your next request to get the next page. An empty cursor indicates no more pages are available.
         * @summary Get Trades
         * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 1000.
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {string} [ticker] Filter by market ticker
         * @param {number} [minTs] Filter items after this Unix timestamp
         * @param {number} [maxTs] Filter items before this Unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrades(limit, cursor, ticker, minTs, maxTs, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTrades(limit, cursor, ticker, minTs, maxTs, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * MarketsApi - factory interface
 */
export const MarketsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = MarketsApiFp(configuration);
    return {
        /**
         * Get a single market by its ticker.  A market represents a specific binary outcome within an event that users can trade on (e.g., \"Will candidate X win?\"). Markets have yes/no positions, current prices, volume, and settlement rules.
         * @summary Get Market
         * @param {string} ticker Market ticker
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarket(ticker, options) {
            return localVarFp.getMarket(ticker, options).then((request) => request(axios, basePath));
        },
        /**
         * Get candlestick data for a market within a series
         * @summary Get Market Candlesticks
         * @param {string} ticker The series ticker
         * @param {string} marketTicker The market ticker
         * @param {number} [startTs] Start timestamp for the range
         * @param {number} [endTs] End timestamp for the range
         * @param {string} [periodInterval] Period interval for candlesticks (e.g., 1m, 5m, 1h, 1d)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketCandlesticks(ticker, marketTicker, startTs, endTs, periodInterval, options) {
            return localVarFp.getMarketCandlesticks(ticker, marketTicker, startTs, endTs, periodInterval, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the orderbook for a market
         * @summary Get Market Orderbook
         * @param {string} ticker Market ticker
         * @param {number} [depth] Depth of the orderbook to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketOrderbook(ticker, depth, options) {
            return localVarFp.getMarketOrderbook(ticker, depth, options).then((request) => request(axios, basePath));
        },
        /**
         * List and discover markets on Kalshi.  A market represents a specific binary outcome within an event that users can trade on (e.g., \"Will candidate X win?\"). Markets have yes/no positions, current prices, volume, and settlement rules.  This endpoint returns a paginated response. Use the \'limit\' parameter to control page size (1-1000, defaults to 100). The response includes a \'cursor\' field - pass this value in the \'cursor\' parameter of your next request to get the next page. An empty cursor indicates no more pages are available.
         * @summary Get Markets
         * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 1000.
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {string} [eventTicker] Filter by event ticker
         * @param {string} [seriesTicker] Filter by series ticker
         * @param {number} [maxCloseTs] Filter items that close before this Unix timestamp
         * @param {number} [minCloseTs] Filter items that close after this Unix timestamp
         * @param {string} [status] Filter by market status. Comma-separated list. Possible values are \&#39;initialized\&#39;, \&#39;open\&#39;, \&#39;closed\&#39;, \&#39;settled\&#39;, \&#39;determined\&#39;. Note that the API accepts \&#39;open\&#39; for filtering but returns \&#39;active\&#39; in the response. Leave empty to return markets with any status.
         * @param {string} [tickers] Filter by specific market tickers. Comma-separated list of market tickers to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarkets(limit, cursor, eventTicker, seriesTicker, maxCloseTs, minCloseTs, status, tickers, options) {
            return localVarFp.getMarkets(limit, cursor, eventTicker, seriesTicker, maxCloseTs, minCloseTs, status, tickers, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all trades for all markets.  A trade represents a completed transaction between two users on a specific market. Each trade includes the market ticker, price, quantity, and timestamp information.  This endpoint returns a paginated response. Use the \'limit\' parameter to control page size (1-1000, defaults to 100). The response includes a \'cursor\' field - pass this value in the \'cursor\' parameter of your next request to get the next page. An empty cursor indicates no more pages are available.
         * @summary Get Trades
         * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 1000.
         * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
         * @param {string} [ticker] Filter by market ticker
         * @param {number} [minTs] Filter items after this Unix timestamp
         * @param {number} [maxTs] Filter items before this Unix timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrades(limit, cursor, ticker, minTs, maxTs, options) {
            return localVarFp.getTrades(limit, cursor, ticker, minTs, maxTs, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * MarketsApi - object-oriented interface
 */
export class MarketsApi extends BaseAPI {
    /**
     * Get a single market by its ticker.  A market represents a specific binary outcome within an event that users can trade on (e.g., \"Will candidate X win?\"). Markets have yes/no positions, current prices, volume, and settlement rules.
     * @summary Get Market
     * @param {string} ticker Market ticker
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarket(ticker, options) {
        return MarketsApiFp(this.configuration).getMarket(ticker, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get candlestick data for a market within a series
     * @summary Get Market Candlesticks
     * @param {string} ticker The series ticker
     * @param {string} marketTicker The market ticker
     * @param {number} [startTs] Start timestamp for the range
     * @param {number} [endTs] End timestamp for the range
     * @param {string} [periodInterval] Period interval for candlesticks (e.g., 1m, 5m, 1h, 1d)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketCandlesticks(ticker, marketTicker, startTs, endTs, periodInterval, options) {
        return MarketsApiFp(this.configuration).getMarketCandlesticks(ticker, marketTicker, startTs, endTs, periodInterval, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the orderbook for a market
     * @summary Get Market Orderbook
     * @param {string} ticker Market ticker
     * @param {number} [depth] Depth of the orderbook to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarketOrderbook(ticker, depth, options) {
        return MarketsApiFp(this.configuration).getMarketOrderbook(ticker, depth, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List and discover markets on Kalshi.  A market represents a specific binary outcome within an event that users can trade on (e.g., \"Will candidate X win?\"). Markets have yes/no positions, current prices, volume, and settlement rules.  This endpoint returns a paginated response. Use the \'limit\' parameter to control page size (1-1000, defaults to 100). The response includes a \'cursor\' field - pass this value in the \'cursor\' parameter of your next request to get the next page. An empty cursor indicates no more pages are available.
     * @summary Get Markets
     * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 1000.
     * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
     * @param {string} [eventTicker] Filter by event ticker
     * @param {string} [seriesTicker] Filter by series ticker
     * @param {number} [maxCloseTs] Filter items that close before this Unix timestamp
     * @param {number} [minCloseTs] Filter items that close after this Unix timestamp
     * @param {string} [status] Filter by market status. Comma-separated list. Possible values are \&#39;initialized\&#39;, \&#39;open\&#39;, \&#39;closed\&#39;, \&#39;settled\&#39;, \&#39;determined\&#39;. Note that the API accepts \&#39;open\&#39; for filtering but returns \&#39;active\&#39; in the response. Leave empty to return markets with any status.
     * @param {string} [tickers] Filter by specific market tickers. Comma-separated list of market tickers to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMarkets(limit, cursor, eventTicker, seriesTicker, maxCloseTs, minCloseTs, status, tickers, options) {
        return MarketsApiFp(this.configuration).getMarkets(limit, cursor, eventTicker, seriesTicker, maxCloseTs, minCloseTs, status, tickers, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get all trades for all markets.  A trade represents a completed transaction between two users on a specific market. Each trade includes the market ticker, price, quantity, and timestamp information.  This endpoint returns a paginated response. Use the \'limit\' parameter to control page size (1-1000, defaults to 100). The response includes a \'cursor\' field - pass this value in the \'cursor\' parameter of your next request to get the next page. An empty cursor indicates no more pages are available.
     * @summary Get Trades
     * @param {number} [limit] Number of results per page. Defaults to 100. Maximum value is 1000.
     * @param {string} [cursor] Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.
     * @param {string} [ticker] Filter by market ticker
     * @param {number} [minTs] Filter items after this Unix timestamp
     * @param {number} [maxTs] Filter items before this Unix timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTrades(limit, cursor, ticker, minTs, maxTs, options) {
        return MarketsApiFp(this.configuration).getTrades(limit, cursor, ticker, minTs, maxTs, options).then((request) => request(this.axios, this.basePath));
    }
}
