/* tslint:disable */
/* eslint-disable */
/**
 * Kalshi Trade API Manual Endpoints
 * Manually defined OpenAPI spec for endpoints being migrated to spec-first approach
 *
 * The version of the OpenAPI document: 3.4.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import globalAxios from 'axios';
// URLSearchParams not necessarily used
// @ts-ignore
import { URL } from 'url';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, setSearchParams, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, BaseAPI } from '../base';
/**
 * ExchangeApi - axios parameter creator
 */
export const ExchangeApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *  Endpoint for getting all exchange-wide announcements.
         * @summary Get Exchange Announcements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeAnnouncements: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/exchange/announcements`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for getting the exchange schedule.
         * @summary Get Exchange Schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeSchedule: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/exchange/schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  Endpoint for getting the exchange status.
         * @summary Get Exchange Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeStatus: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/exchange/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get Series Fee Changes
         * @param {string} [seriesTicker]
         * @param {boolean} [showHistorical]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesFeeChanges: (seriesTicker_1, showHistorical_1, ...args_1) => __awaiter(this, [seriesTicker_1, showHistorical_1, ...args_1], void 0, function* (seriesTicker, showHistorical, options = {}) {
            const localVarPath = `/series/fee_changes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (seriesTicker !== undefined) {
                localVarQueryParameter['series_ticker'] = seriesTicker;
            }
            if (showHistorical !== undefined) {
                localVarQueryParameter['show_historical'] = showHistorical;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *  There is typically a short delay before exchange events are reflected in the API endpoints. Whenever possible, combine API responses to PUT/POST/DELETE requests with websocket data to obtain the most accurate view of the exchange state. This endpoint provides an approximate indication of when the data from the following endpoints was last validated: GetBalance, GetOrder(s), GetFills, GetPositions
         * @summary Get User Data Timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDataTimestamp: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/exchange/user_data_timestamp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ExchangeApi - functional programming interface
 */
export const ExchangeApiFp = function (configuration) {
    const localVarAxiosParamCreator = ExchangeApiAxiosParamCreator(configuration);
    return {
        /**
         *  Endpoint for getting all exchange-wide announcements.
         * @summary Get Exchange Announcements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeAnnouncements(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getExchangeAnnouncements(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for getting the exchange schedule.
         * @summary Get Exchange Schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeSchedule(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getExchangeSchedule(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  Endpoint for getting the exchange status.
         * @summary Get Exchange Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeStatus(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getExchangeStatus(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *
         * @summary Get Series Fee Changes
         * @param {string} [seriesTicker]
         * @param {boolean} [showHistorical]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesFeeChanges(seriesTicker, showHistorical, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSeriesFeeChanges(seriesTicker, showHistorical, options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
        /**
         *  There is typically a short delay before exchange events are reflected in the API endpoints. Whenever possible, combine API responses to PUT/POST/DELETE requests with websocket data to obtain the most accurate view of the exchange state. This endpoint provides an approximate indication of when the data from the following endpoints was last validated: GetBalance, GetOrder(s), GetFills, GetPositions
         * @summary Get User Data Timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDataTimestamp(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserDataTimestamp(options);
                const localVarOperationServerIndex = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const localVarOperationServerBasePath = undefined;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
            });
        },
    };
};
/**
 * ExchangeApi - factory interface
 */
export const ExchangeApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ExchangeApiFp(configuration);
    return {
        /**
         *  Endpoint for getting all exchange-wide announcements.
         * @summary Get Exchange Announcements
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeAnnouncements(options) {
            return localVarFp.getExchangeAnnouncements(options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for getting the exchange schedule.
         * @summary Get Exchange Schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeSchedule(options) {
            return localVarFp.getExchangeSchedule(options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint for getting the exchange status.
         * @summary Get Exchange Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeStatus(options) {
            return localVarFp.getExchangeStatus(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get Series Fee Changes
         * @param {string} [seriesTicker]
         * @param {boolean} [showHistorical]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSeriesFeeChanges(seriesTicker, showHistorical, options) {
            return localVarFp.getSeriesFeeChanges(seriesTicker, showHistorical, options).then((request) => request(axios, basePath));
        },
        /**
         *  There is typically a short delay before exchange events are reflected in the API endpoints. Whenever possible, combine API responses to PUT/POST/DELETE requests with websocket data to obtain the most accurate view of the exchange state. This endpoint provides an approximate indication of when the data from the following endpoints was last validated: GetBalance, GetOrder(s), GetFills, GetPositions
         * @summary Get User Data Timestamp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDataTimestamp(options) {
            return localVarFp.getUserDataTimestamp(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ExchangeApi - object-oriented interface
 */
export class ExchangeApi extends BaseAPI {
    /**
     *  Endpoint for getting all exchange-wide announcements.
     * @summary Get Exchange Announcements
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExchangeAnnouncements(options) {
        return ExchangeApiFp(this.configuration).getExchangeAnnouncements(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for getting the exchange schedule.
     * @summary Get Exchange Schedule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExchangeSchedule(options) {
        return ExchangeApiFp(this.configuration).getExchangeSchedule(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  Endpoint for getting the exchange status.
     * @summary Get Exchange Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getExchangeStatus(options) {
        return ExchangeApiFp(this.configuration).getExchangeStatus(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get Series Fee Changes
     * @param {string} [seriesTicker]
     * @param {boolean} [showHistorical]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSeriesFeeChanges(seriesTicker, showHistorical, options) {
        return ExchangeApiFp(this.configuration).getSeriesFeeChanges(seriesTicker, showHistorical, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *  There is typically a short delay before exchange events are reflected in the API endpoints. Whenever possible, combine API responses to PUT/POST/DELETE requests with websocket data to obtain the most accurate view of the exchange state. This endpoint provides an approximate indication of when the data from the following endpoints was last validated: GetBalance, GetOrder(s), GetFills, GetPositions
     * @summary Get User Data Timestamp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserDataTimestamp(options) {
        return ExchangeApiFp(this.configuration).getUserDataTimestamp(options).then((request) => request(this.axios, this.basePath));
    }
}
